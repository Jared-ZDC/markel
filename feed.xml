<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/Jared-ZDC/markel</id><title>RSS feed of Jared-ZDC's markel</title><updated>2026-01-19T07:31:30.815716+00:00</updated><link href="https://github.com/Jared-ZDC/markel"/><link href="https://raw.githubusercontent.com/Jared-ZDC/markel/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/Jared-ZDC/markel/issues/56</id><title>2026年度计划</title><updated>2026-01-19T07:31:31.209416+00:00</updated><content type="html"><![CDATA[<p><strong>26年整体期望目标达成率 70%以上</strong></p>
<p>整体还是分为4个维度跟踪：工作、生活、学习、理财；</p>
<!-- more -->
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/56"/><category term="年度计划"/><published>2026-01-19T07:12:41+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/55</id><title>25年度总结</title><updated>2026-01-19T07:31:31.338559+00:00</updated><content type="html"><![CDATA[<p>先不看2025年初制定的计划，从自己的回忆中对2025做个整理盘点，主要是三个方向： 工作、学习、生活、理财；</p>
<ul>
<li>工作 --- 75</li>
<li>学习 --- 50</li>
<li>理财 --- 30</li>
<li>生活 --- 50</li>
</ul>
<p><strong>全年得分： 205，达成率 51.25%</strong></p>
<p><strong>一句话总结：毫无起色，毫无锚点！</strong></p>
<h1>工作</h1>
<p>单纯从工作来看，今年几个项目交付都很完美，我觉得达成了既定的目标，没有花太多心思在里面，但是结果是好的，这个一方面归功于识人，让对应的人在对应的岗位上，能够踏踏实实的干活，另外一方面，也归功于运气；但是总而言之，今年上半年在工作上，交付的都很顺利，这一点很满意；</p>
<!-- more -->
<p>下半年更多的在于自己的发展规划学习，从理论上，完成了一些课程的基础知识的吸收，算是入门了吧，但是整体上其实离目标有一些距离；今年年初定的课程，其实大部分没有完成学习，哎，这个还是因为自己的内核不够稳定，不确定未来要怎么样的人生； 今年在这个方面要多想想，40不惑，现在也差不多到这个年纪了，可是自己还是有很多很多东西想不明白，想不清楚；</p>
<p>所以从工作这个点来总结的话，我觉得可以给25年打<strong>75</strong>分吧，上半年满分，下半年50分。 </p>
<h1>学习</h1>
<p>今年的学习，更多的偏向于AI方向，但是整体课程其实就完成了李宏毅的机器学习，其它还是偏零散的看了一些AI相关的，不过基本上，算达成了入门的目标，也能够跟相关的人进行对话，但是怎么说呢，还是偏向于表面， 原本规划了很多的学习，其实最终没有达成；</p>
<p>1、手机摄影的学习没有完成，收藏了也没有看；
2、AI 编译器等还有很多相关的也没有完成学习，在平时的时间安排上面，还是放松太多了
3、量化也没有完成，只是形成了大致的思路；
4、目标一月一本书也没有达成，差的有点多；</p>
<p>所以整体上， 我觉得针对学习的话，可能勉强算<strong>50</strong>分吧；</p>
<h1>理财</h1>
<p>原本计划的目标：
1、完成初步的回测框架 ----  算是完成了吧，但是没有实际写过几个策略
2、量化的框架完成 --- 只能算完成基本的开发思路以及数据库建设，但是整个端到端还没有完成，总是拖沓、畏难；
3、研究报告 --- 完成度 0 </p>
<p>所以这里今年只能打<strong>30</strong>分</p>
<h1>生活</h1>
<p>原本的计划目标：
1、减肥到140斤以内 或者 体脂20%以内；  --- 结果是反向减脂，得分<strong>0</strong>分
2、月度回归也没有进行下去，消费记录也没有进行下去， 大致进行了半年吧  --- 得分 50
3、徒步、游泳、早睡、旅途等等，可能部分开展了，但是整体差距还是较大 --- 得分 30
4、感情上算是有一个改变吧， 希望一切都是最好的安排 --- 得分 50</p>
<p>整体上，今年的生活并没有太多的改善，没有体现出这个人生的价值；没有太多记忆锚点，太普通了；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/55"/><category term="年度计划"/><published>2026-01-04T02:38:44+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/54</id><title>投资企业的几种类型 --- 牢记于心</title><updated>2026-01-19T07:31:31.450296+00:00</updated><content type="html"><![CDATA[<p>冯柳的一个帖子中说道， 企业分成几类：</p>
<ul>
<li><strong>不作死就不会死</strong></li>
<li><strong>作死也死不了</strong></li>
<li><strong>不作死都能死</strong></li>
</ul>
<p>其中 ：</p>
<p>类型一：<em>地方酒、发达地区城商行、民营险资、细分龙游消费股属于<strong>不作死就不会死</strong></em></p>
<p>类型二： <strong>央企保险公司、六大国有银行、头部券商、煤炭、电力、石油、头部白酒、啤酒、牛奶都属于作死也死不了的；</strong></p>
<p>类型三：汽车、科技、零售、医药、中断制造业、时尚快消品（如化妆品、女装）这些就属于<strong>不作死（不进步）都能死</strong>！</p>
<p>所以从保本收益的情况来看， 后续的投资标的只能从<strong>类型二</strong>里面出，避免想赚快钱，比如再遇到协鑫科技这类股票，安全边际非常不够；</p>
<!-- more -->]]></content><link href="https://github.com/Jared-ZDC/markel/issues/54"/><category term="投资交易"/><published>2025-04-26T05:53:22+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/53</id><title>使用 QEMU 启动 ARM aarch64 架构 Ubuntu 虚拟机</title><updated>2026-01-19T07:31:31.582064+00:00</updated><content type="html"><![CDATA[<p>本文将介绍如何使用 QEMU 启动 aarch64 架构的 Ubuntu 操作系统以及宿主机上相关配置的操作方法。</p>
<h1>安装 QEMU</h1>
<p>安装启动 aarch64 ubuntu 所需的依赖程序：</p>
<pre><code class="language-bash">sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils virtinst virt-manager qemu
sudo apt install qemu-system-aarch64
sudo apt install qemu-efi-aarch64
sudo apt install qemu-utils
</code></pre>
<h1>创建镜像</h1>
<pre><code class="language-bash">dd if=/dev/zero of=flash1.img bs=1M count=64
dd if=/dev/zero of=flash0.img bs=1M count=64
dd if=/usr/share/qemu-efi-aarch64/QEMU_EFI.fd of=flash0.img conv=notrunc


wget http://ports.ubuntu.com/ubuntu-ports/dists/xenial-updates/main/installer-arm64/current/images/netboot/mini.iso

qemu-img create ubuntu-image.img 20G


</code></pre>
<h1>安装系统</h1>
<pre><code class="language-bash">qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 512M -cpu max -smp 4 \
-netdev user,id=vnet,hostfwd=:127.0.0.1:0-:22 -device virtio-net-pci,netdev=vnet \
-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback -device virtio-blk,drive=drive0,bootindex=0 \
-drive file=mini.iso,if=none,id=drive1,cache=writeback -device virtio-blk,drive=drive1,bootindex=1 \
-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash 

</code></pre>
<h1>启动镜像</h1>
<pre><code class="language-bash">网络架构：
+-----------------------------------------------------------------+
|  Host                                                           |
| +---------------------+                                         |
| |                     |                                         |
| | br0:                |                                         |
| |   192.168.199.32/24 +-----+                                   |
| |                     |     |                                   |
| +----+----------------+     |       +-------------------------+ |
|      |                      |       |  Guest                  | |
|      |                      |       | +---------------------+ | |
| +----+----------------+  +--+---+   | |                     | | |
| |                     |  |      |   | | eth0:               | | |
| | enp3s0:             |  | tap0 |   | |   192.168.199.33/24 | | |
| |   192.168.199.30/24 |  |      +-----+                     | | |
| |                     |  |      |   | +---------------------+ | |
| +---------------------+  +------+   +-------------------------+ |
+-----------------------------------------------------------------+


# 配置网桥
sudo ip link add name br0 type bridge
sudo ip link set dev br0 down
sudo ip addr flush dev br0
sudo ip addr add 192.168.199.32/24 dev br0
sudo ip link set dev br0 up

# 配置 tap 设备 tap0：
sudo ip tuntap add name tap0 mode tap
sudo ip link set dev tap0 up

# 将宿主机网络接口 enp3s0 和 tap0 接入网桥 br0：
sudo ip link set enp3s0 master br0
sudo ip link set tap0 master br0

# 启动虚拟机系统：
sudo qemu-system-aarch64 -nographic -machine virt,gic-version=max -m 1G -cpu max -smp 4 \
-netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no \
-device virtio-net-pci,netdev=mynet0,mac=$(qemu-mac-hasher.py ubuntu1604-arm64) \
-drive file=ubuntu-image.img,if=none,id=drive0,cache=writeback \
-device virtio-blk,drive=drive0,bootindex=0 \
-drive file=flash0.img,format=raw,if=pflash -drive file=flash1.img,format=raw,if=pflash \
-device virtio-rng-pci

# 以上命令指定 qemu 使用 tap 设备作为虚拟机网络接口并且指定使用刚刚创建的 tap0 接口。

# 为了指定虚拟器的 MAC 地址我们使用一个脚本来为每个虚拟机生成特定地址。MAC 地址的生成脚本如下：

# qemu-mac-hasher.py
#!/usr/bin/env python
# usage: qemu-mac-hasher.py &lt;VMName&gt;
import sys
import zlib

crc = str(hex(zlib.crc32(sys.argv[1].encode(&quot;utf-8&quot;))))[-8:]
print(&quot;52:54:%s%s:%s%s:%s%s:%s%s&quot; % tuple(crc))

# 虚拟机启动后根据需要配置其网络参数即可。
</code></pre>
<h1>网络优化</h1>
<p>以上步骤完成后虚拟机可与宿主机所在网络的其他设备互连（包括宿主机），也可以通过指定的网关连接互联网，但是此时宿主机无法连接互联网，解决方法如下：</p>
<p>删除 enp3s0 接口的默认网关, 为 br0 添加默认网关：</p>
<pre><code class="language-bash">sudo ip route del default dev enp3s0
sudo ip route add default via 192.168.199.1 dev br0
</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/53"/><category term="程序人生"/><published>2025-04-26T05:40:32+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/52</id><title>iperf2 交叉编译 ARM64 static版本</title><updated>2026-01-19T07:31:31.710741+00:00</updated><content type="html"><![CDATA[<p>编译静态版本的iperf2，到嵌入式环境进行测试；</p>
<p>iperf2 可以利用多核多线程并行测试，iperf3的多核是运行在一个物理核上面，只是软件意义上的多核；</p>
<pre><code class="language-patch">(base) root@mengxia01:~/code/iperf-2.0.4-RELEASE# diff config.h ../iperf-2.0.4-arm/config.h
258c258
&lt; //#define bool int  
---
&gt; #define bool int
</code></pre>
<pre><code class="language-bash">#编译命令
./configure  --host=arm CC=aarch64-linux-gnu-gcc   CXX=aarch64-linux-gnu-g++   CFLAGS=&quot;-static -fPIE -fPIC&quot;   LDFLAGS=&quot;-static -fPIE -fPIC&quot;
</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/52"/><category term="程序人生"/><published>2025-04-25T11:01:12+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/51</id><title>Linux perf工具静态编译</title><updated>2026-01-19T07:31:31.849366+00:00</updated><content type="html"><![CDATA[<p>在嵌入式环境中，有时候相关库比较少，所以需要单独编译静态版本的perf工具去定位问题，这里仅仅作为关键步骤记录，以备后续查阅</p>
<!-- more -->
<pre><code class="language-patch"># 修改Makefile.config文件
diff --git a/tools/perf/Makefile.config b/tools/perf/Makefile.config
index a92f0f025ec7..87a6e97ff1f8 100644
--- a/tools/perf/Makefile.config
+++ b/tools/perf/Makefile.config
@@ -16,7 +16,7 @@ $(shell printf &quot;&quot; &gt; $(OUTPUT).config-detected)
 detected     = $(shell echo &quot;$(1)=y&quot;       &gt;&gt; $(OUTPUT).config-detected)
 detected_var = $(shell echo &quot;$(1)=$($(1))&quot; &gt;&gt; $(OUTPUT).config-detected)

-CFLAGS := $(EXTRA_CFLAGS) $(filter-out -Wnested-externs,$(EXTRA_WARNINGS))
+CFLAGS := $(EXTRA_CFLAGS) $(filter-out -Wnested-externs,$(EXTRA_WARNINGS)) -static

 include $(srctree)/tools/scripts/Makefile.arch

</code></pre>
<pre><code class="language-bash"># 执行编译
cd tools/perf
make clean
make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- perf  V=1
</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/51"/><category term="程序人生"/><published>2025-04-25T10:53:21+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/50</id><title>协鑫科技 --- 二次失利总结</title><updated>2026-01-19T07:31:32.001232+00:00</updated><content type="html"><![CDATA[<p><strong>第一次失利：</strong>
<strong>均价</strong>：2.5   <strong>离场</strong>：1.5， <strong>亏损</strong>：40%</p>
<p>第一次购买协鑫科技的时候，还是2020年， 那个时候我盘点大盘可能会持续走低，本来就清空了所有股票，可是被别人消息说，协鑫科技颗粒硅怎么怎么样，没忍住，持续性的加仓，从2.8一直加仓到2.2，把均价干到了2.5，但是实际上对这只股票根本没有分析，也没有仔细去看这只股票的安全边际；</p>
<p>买股票， 第一要考虑是否有足够的<strong>安全边际</strong>，<strong>坚决不做小盘股</strong>！</p>
<p><strong>第二次失利：</strong>
<strong>均价</strong>：1.1   <strong>离场</strong>：0.85， <strong>亏损</strong>：23%</p>
<p>这一次更多的是看到协鑫这一两年的表现一直在一个区间内波动，想去赚这个投机的钱，结果投机钱没有赚到，本金亏了不少；
也不敢持续加仓，因为没有看到安全边际；</p>
<p><strong>总结一下原则：</strong></p>
<ul>
<li><strong>坚决不买小盘股</strong>，只做国家拖底的行业；</li>
<li>只做<strong>安全边际高</strong>的行业</li>
<li><strong>不做科技类行业</strong>，就算赚的少也不买</li>
</ul>
<!-- more -->]]></content><link href="https://github.com/Jared-ZDC/markel/issues/50"/><category term="投资交易"/><published>2025-04-07T01:56:11+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/49</id><title>2025 预算及消费</title><updated>2026-01-19T07:31:32.133619+00:00</updated><content type="html"><![CDATA[<p>今年整体看看每年的消费，做一个预算与消费的统计吧，感觉每个月花费有点大，要稍微控制一下；</p>
<h1>3月份预算</h1>
<ul>
<li>房贷-&gt; 邮政+北京银行合计 :  11000</li>
<li>饮食-&gt; 100 * 30 : 3000</li>
<li>请客送礼： 2000</li>
<li>水电话费： 1000</li>
<li>娱乐 ： 1500</li>
<li>生活杂费： 1500</li>
</ul>
<p><strong>合计：20000</strong> </p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/49"/><category term="年度计划"/><published>2025-03-10T06:59:46+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/48</id><title>2025年的计划</title><updated>2026-01-19T07:31:32.272972+00:00</updated><content type="html"><![CDATA[<p>2024年12月29日，今天跟老父亲徒步了12公里，在西湖以及灵隐寺好好逛了一下，也算是弥补父亲来杭州几个月没有带他出去走走的遗憾！
<img src="https://github.com/user-attachments/assets/94080d06-0f24-4f31-88ce-36a1a9b33d91" alt="我的父亲" /></p>
<p>24年已经快过完了，也到时候需要好好思考明年的规划的时候； 虽然坦白说，每年都会给自己做很多的计划，规划，最后似乎都没有达成，但是总觉得，做了总比不做要强，至少有一个地方提醒着自己，有些事情还需要自己完成；</p>
<p>想从这几个方面想一下25年的事情：</p>
<ul>
<li>职业规划</li>
<li>工作</li>
<li>生活</li>
<li>学习
感情暂时先不写吧，因为这件事是我一直犹豫不定的，暂且就先这样吧，人之所以为人，可能就是因为有感情，当然也可能是有借口；</li>
</ul>
<!-- more -->
<h1>职业规划</h1>
<p>其实从最近几年自己的成长来看，其实很明显的可以感觉到在芯片这个行业里面，自己的职业天花板基本上已经形成了，或者说很明显的感觉到瓶颈无法打破；</p>
<p>仔细想看，可能有几个方面的原因：</p>
<ul>
<li>基础确实相对较差，自己本科出身，大学阶段大部分的时间也是在混日子，在芯片这个行业里面，不得不说，对于数学、英语等专业知识，对于科研的学习能力实际上要求的是比较高的，而从自身的素质来看，我更偏向于快速应用类的人，对于一个新的东西，我能很快的通过周边的资源整合快速使用起来，但是对于这个事情的实际的原理，细节甚至更深的扩展，理解是很弱的，自我的性格上，更偏向于快速看到结束，急功近利，浮于表面，很难沉下心进行研究，这也是自己看起来什么都会一点，但是样样通，样样松的原因；这一点，实际上也限制了自己往纯技术领域发展的可能性；</li>
<li>职位限制，目前我所在的岗位属于芯片领域里面的软件岗位，如果从职业发展通道来看，做到部门经理已经是这个职业发展的天花板了，如果再往上，可以看到的路径，要么是产品线负责人，要么是产品线项目经理的角色；从自己的技术栈以及影响力来看，这两个都不是自己能够胜任的，因为在芯片这个技术序列里面来看，很难说让一个软件出身的人去带领芯片设计、架构、实现等等部门的总负责人或者项目经理；那么跳脱这个职位限制，实际上也没有特别好的职业能够承接当前的收入，因此可见的，职业生涯应该是止步于部门经理的角色，当然这个也已经做到了大部分人的职业天花板，从收入以及影响力来说，已经比较好了；</li>
<li>边际效应，目前从部门经理的角色来看，大部分的时间花在部门的管理以及项目的推动上；如果挤出大量的时间去补足当前行业的知识空缺，可能带来的收益并不明显，或许需要大量其它岗位的技能支持才能让自己在后续有可能跨到别的职位或者维持当前的职位，但是从收入上，可能不见得会有多少的提升，甚至仅仅是持平，那么这个投入产出比，需要打个问号？！</li>
</ul>
<p>不得不说，自己在这个行业里面能够走到当前的位置，一方面纯属运气，吃到了这个行业快速发展的红利，无论是地缘政治引起的国产化的原因，还是国家在这个行业里面的大量投资引起的金融化浪潮；都让我跟随着这个风口，自己的收入，待遇，职位都有比较大的提升；其次是个人前几年的努力以及相对抗压耐操的品性，熬过了几次想要中途放弃的想法，熬走了更有资历的同学；但是未来可见的空间，感觉不是纯属努力能够解决的；有人说，大部分人都没有到拼天赋的时候，因为大部分当前的职业还没有到一定的层度，但是到目前为止，我认为可能确实已经到了要拼天赋的时候了，此时，是否还有必要继续咬着牙拼这条路的刺刀呢？这里我想明确的告诉自己：</p>
<blockquote>
<p><strong>当前的目标是维持好部门经理的角色，让职业天花板生存期持续的时间可以更长一些，可以预见他会慢慢走下破路，但是要带着刹车走！其次做好投资副业的知识储备，无论是价值投机方向，还是量化方向，再到个人的资产配置，做好相关的应对准备！</strong></p>
</blockquote>
<h1>工作规划</h1>
<p>按照当前设定的职业规划的目标：<strong>维持好部门经理的角色，让职业天花板生存期持续的时间可以更长一些</strong>，那么2025年，可能需要做几件事情：</p>
<ul>
<li>培养几个能够独放一面的人， 目前看NJ团队的TC/TXL 可以撑起来，SZ团队的DB可以，HZ团队基本上偏向执行，时不时跟进一下进度就可以；让几个领域的负责人把相关的活动扛起来，我更多的偏向做好质量把控以及监督、督促的作用，当然这里需要多参加一些会议，自我的作用需要体现出来，不能完全放手，否则自我的价值无法体现，容易被汰换；<strong>事情交给他们做，决策由自己下</strong>， 多做担责的事情，这样不容易出现问题，但是事情承载又会比较少；</li>
<li>部门规范需要完善，这部分可以继续总结经验，尽快完成输出；</li>
<li>AI相关的知识需要补充，这一点无论是工作上的需要还是未来投资上面可能也会需要，因此这一块需要从算法、编译器到芯片都能够整体的摸一下；</li>
<li>一些模块的基本功能也需要找时间看一下，知识面可以继续补充一下，但是深度不要求多高，主要偏向于了解基本的模块用途以及工作原理</li>
<li>保持跟领导的链接，这部分还是按照月度跟领导做好沟通以及汇报，但是汇报的东西可以虚化一下，多偏向一些规划以及规划的进展；</li>
<li>今年的项目好好交付一下，这里有一些小心机，一些重要的会议，要体现自己的价值，或者说组织相关的攻关会，在里面体现出要做的事情，主要是让自己参与其中</li>
</ul>
<h1>生活规划</h1>
<p>随着年纪越来越大，发现时间过得真的越来越快，一下子一年就过去了，惶惶然，这辈子已经到了快中年的时候；
生命中，太多时间浪费在无意义的事情上面，或者浪费在工作上面； 来这世间一趟，我觉得最重要的就是体验，足够丰富的经历，让我这辈子觉得没有白来！！！
所以今年，我要改变一下生活的状态，多出去看看这个世界，用脚步，用眼睛去体会不一样的人生；</p>
<ul>
<li>尝试跑个半马，把自己的身体状态恢复一下，就算回不到年轻的时候，也能改善一下</li>
<li>尝试学会自由泳，自己学，自己练</li>
<li>尝试周末多出去走走，多出去看看</li>
</ul>
<h1>理财规划</h1>
<p>这个我觉得有必要单独展开想一想，自己的工资应该怎么持续的增值，首先一点，不能贪，要把多少放到保本低收益下，比如债券，比如银行等，要把多少放到高分红类的股，有多少进行高风险的股票上，这些要先思考好，不着急，这里单独想想</p>
<p>更重要的事，这里要应对的是为未来几十年的生活做好底蕴，打好底子；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/48"/><category term="年度计划"/><published>2024-12-29T13:22:34+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/47</id><title>backtrader 简单双均线策略</title><updated>2026-01-19T07:31:32.405881+00:00</updated><content type="html"><![CDATA[<p>策略的主要行为：
1） 初始化5日均线以及20日均线，sma5， sma20
2)    sma5上穿sma20买入
3） sma5 下穿sma20卖出</p>
<p>策略绩效：</p>
<pre><code class="language-bash">Starting Portfolio Value: 100000.00
Final Portfolio Value: 99796.00
</code></pre>
<!-- more -->
<pre><code class="language-python"># 简单用双均线，测试一下
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import time

from backtest.tool import *
import backtrader as bt

# Create a Stratey
class TestStrategy(bt.Strategy):
    params = (
        (&#x27;period_low&#x27;, 5),
        (&#x27;period_high&#x27;, 20),
    )

    def log(self, txt, dt=None):
        &#x27;&#x27;&#x27; Logging function for this strategy&#x27;&#x27;&#x27;
        dt = dt or self.datas[0].datetime.date(0)
        print(&#x27;%s, %s&#x27; % (dt.isoformat(), txt))

    def __init__(self):
        self.sma_low = bt.indicators.SimpleMovingAverage(self.datas[0].close, period=self.params.period_low)
        self.sma_high = bt.indicators.SimpleMovingAverage(self.datas[0].close, period=self.params.period_high)
        self.sell_sig = self.sma_high &gt; self.sma_low
        self.buy_sig = self.sma_high &lt; self.sma_low
        self.last_sig = False #上一次信号是买或者是卖， False表示上一次是卖
    def next(self):
        if self.sell_sig[0] and self.last_sig :
            self.sell()
            self.last_sig = False

        if self.buy_sig[0] and not self.last_sig:
            self.buy()
            self.last_sig = True



if __name__ == &#x27;__main__&#x27;:
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    df = load_data_from_csv(&quot;000001.SZ&quot;)
    # 加载数据
    data = bt.feeds.PandasData(dataname=df, fromdate=pd.to_datetime(&quot;20100101&quot;, format=&#x27;%Y%m%d&#x27;),
                               todate=pd.to_datetime(&quot;20241201&quot;, format=&#x27;%Y%m%d&#x27;))

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Print out the starting conditions
    print(&#x27;Starting Portfolio Value: %.2f&#x27; % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print(&#x27;Final Portfolio Value: %.2f&#x27; % cerebro.broker.getvalue())

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/47"/><category term="程序人生"/><published>2024-12-20T03:21:08+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/46</id><title>backtrader （一）</title><updated>2026-01-19T07:31:32.546746+00:00</updated><content type="html"><![CDATA[<p>当前组合版本： numpy==1.23.5   backtrader==1.9.78.123 matplotlib==5.6</p>
<p>但是始终在调用plot的时候出现错误：</p>
<pre><code class="language-bash">AttributeError: &#x27;Plot_OldSync&#x27; object has no attribute &#x27;mpyplot&#x27;

</code></pre>
<p>尝试过不同的版本，都解决不了这个问题，目前尚不知道什么原因，暂时不使用画图，或者后续有空了用pyecharts自己画；</p>
<!-- more -->
<pre><code class="language-python">from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

from backtest.tool import *


# Create a Stratey
class TestStrategy(bt.Strategy):

    def log(self, txt, dt=None):
        &#x27;&#x27;&#x27; Logging function for this strategy&#x27;&#x27;&#x27;
        dt = dt or self.datas[0].datetime.date(0)
        print(&#x27;%s, %s&#x27; % (dt.isoformat(), txt))

    def __init__(self):
        # Keep a reference to the &quot;close&quot; line in the data[0] dataseries
        self.dataclose = self.datas[0].close

    def next(self):
        # Simply log the closing price of the series from the reference
        self.log(&#x27;Close, %.2f&#x27; % self.dataclose[0])


if __name__ == &#x27;__main__&#x27;:
    # Create a cerebro entity
    cerebro = bt.Cerebro()

    # Add a strategy
    cerebro.addstrategy(TestStrategy)

    df = load_data_from_csv(&quot;000001.SZ&quot;)

    #加载数据
    data = dataframe_to_datafeeds(df)

    # Add the Data Feed to Cerebro
    cerebro.adddata(data)

    # Set our desired cash start
    cerebro.broker.setcash(100000.0)

    # Print out the starting conditions
    print(&#x27;Starting Portfolio Value: %.2f&#x27; % cerebro.broker.getvalue())

    # Run over everything
    cerebro.run()

    # Print out the final result
    print(&#x27;Final Portfolio Value: %.2f&#x27; % cerebro.broker.getvalue())


</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/46"/><category term="程序人生"/><published>2024-12-19T08:28:25+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/45</id><title>自洽</title><updated>2026-01-19T07:31:32.712568+00:00</updated><content type="html"><![CDATA[<p>我经常喜欢问自己，什么样的人生是自己想要的； 或者说，怎么样才能过好自己的一生；
以前听过一句话，<strong>“不因虚度年华而悔恨，不因碌碌无为而羞耻”</strong>，出自《钢铁是怎样练成的》， 颇为赞同！
那么，怎么样才能不会虚度年华呢？怎么又算不碌碌无为呢？最终的结果取决于如何定义虚度年华，如何定义碌碌无为，如何做到对其逻辑自洽，不会陷入内耗中，欣然面对一切；</p>
<!-- more -->]]></content><link href="https://github.com/Jared-ZDC/markel/issues/45"/><category term="生活感悟"/><published>2024-12-10T02:03:24+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/44</id><title>成年人的世界，有些人注定只能陪你一阵子</title><updated>2026-01-19T07:31:32.859876+00:00</updated><content type="html"><![CDATA[<p>我们这一辈子，会遇见很多人，<strong>有的人会陪你一阵子，有的人注定只是你生命的过程。</strong></p>
<p>世上没有两个一模一样的人，
在你生命中出现的所有人，
只是茫茫人海中，很小很小的一部分，
每个来到你身边的人，都是缘分所至。</p>
<p>人生是单程旅行，
在这趟“生命班列”上，
与你一同上“车”的父母，会在中途下“车”，
中途上车的爱人、孩子和朋友，也只能伴你一程。</p>
<p>我们能做的只是与同行的人，
在同行的时间里，共享喜怒悲乐，
且行，且珍惜。</p>
<p>分手时，
再怎样万般不舍，
也得互道“珍重”，
默默地望着他们远去，
然后孤独前行。</p>
<p>我们每个人都是这个世界的过客，
当生命抵达“终点站”时，
下“车”的只有我们自己。</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/44"/><category term="生活感悟"/><published>2024-12-09T11:08:37+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/43</id><title>AI 全栈工程师实现路径</title><updated>2026-01-19T07:31:33.005975+00:00</updated><content type="html"><![CDATA[<p>学习AI相关的软硬件全栈，涵盖应用、算法、编译器、底层软件（底软）、芯片架构等多个方面，是一项复杂且具有挑战性的任务。为了有效地构建这一领域的知识体系，建议采取分阶段的学习策略，并结合理论与实践。以下是详细的指导路径以及推荐的书籍和课程资源：</p>
<h3>1. 基础准备</h3>
<p>首先，确保你掌握了计算机科学的基础知识，包括但不限于数据结构、算法设计、操作系统原理等。同时，数学基础如线性代数、概率论和统计学也是必不可少的，因为它们构成了机器学习和深度学习的核心理论。</p>
<h3>2. 编程语言与工具</h3>
<p>选择一种主流的编程语言作为主要开发工具，Python 是目前最流行的选择之一，尤其是在AI领域。你可以通过在线平台如Coursera上的《Python for Everybody》课程来开始学习Python 。此外，熟悉常用的库和框架，例如NumPy、Pandas、Scikit-learn 和 TensorFlow 或 PyTorch 等深度学习框架。</p>
<!-- more -->
<h3>3. 机器学习与深度学习</h3>
<p>接下来，深入研究机器学习的基本概念和技术。吴恩达教授在Coursera上提供的《Machine Learning》专项课程是一个很好的起点。对于更高级的内容，可以考虑阅读《Deep Learning》这本书，它由Ian Goodfellow等人编写，被认为是深度学习领域的权威参考书。</p>
<h3>4. AI系统与编译器</h3>
<p>了解AI系统的整体架构及其组件之间的相互作用非常重要。《智能计算系统：从深度学习到大模型（第2版）》不仅涵盖了深度学习的基础，还详细介绍了如何构建支持大规模模型训练的智能计算系统。关于AI编译器的具体实现细节，《AI编译器开发指南》提供了全面的技术梳理和技术实战案例。</p>
<h3>5. 芯片架构与硬件加速</h3>
<p>探索AI专用处理器（如GPU, TPU, FPGA, ASIC）的工作原理及优化方法。这可以通过阅读相关文献或参加专门针对AI硬件设计的工作坊来完成。华为昇腾系列处理器及其配套的MindSpore框架就是一个很好的例子，展示了如何将先进的硬件特性集成到高效的AI解决方案中。</p>
<h3>6. 实践项目</h3>
<p>动手实践是巩固所学知识的关键。尝试参与开源项目或竞赛（如Kaggle），利用实际问题锻炼你的技能。也可以基于公开的数据集进行实验，比如使用MNIST手写数字识别数据集来练习图像分类任务。</p>
<h3>7. 持续学习与发展</h3>
<p>AI技术日新月异，因此保持对最新研究成果的关注至关重要。订阅顶尖期刊、参加学术会议和技术论坛，都是获取前沿信息的好途径。此外，加入专业社群，与其他从业者交流心得，可以帮助你更快地成长。</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/43"/><category term="读书笔记"/><published>2024-12-09T05:50:33+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/42</id><title>近期乱想</title><updated>2026-01-19T07:31:33.123490+00:00</updated><content type="html"><![CDATA[<p>最近这一个多月自己有点放弃自律了，因为感情上的一些问题；
前段时间核心人员想要离职，跟他聊了快一个通宵，因为在一起共事了很多年，也算是一个比较知心的朋友；其中有聊到彼此的感情问题；在他的婚姻中，他即是幸运的，也是不幸的； 当时因为年纪到了，急冲冲的找了个人结婚，可是这样的婚姻带给他的却不是幸福，是无止尽的争吵，内耗，最终这段婚姻坚持了不到一年告破，也导致了他背上了一笔不小的负债；这些年的奋斗，到头来，一无所有， 这也是他想要离开这里，博取更高收益的原因；
这不由的联想到自己，我似乎也到了要着急结婚的年纪，但是我目前的情况，适不适合在老家找一个呢？自己的工作一直这么不稳定，哎，真难； 其实我也很想老婆孩子热炕头，可是有什么办法呢？
再给自己一点时间吧，想想透彻，如果最终还是不行，或许，算了，没有或许！</p>
<!-- more -->
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/42"/><category term="生活感悟"/><published>2024-11-18T05:52:53+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/40</id><title>国庆小思</title><updated>2026-01-19T07:31:33.250460+00:00</updated><content type="html"><![CDATA[<p>国庆期间跟朋友聊天，关于职业天花板的问题，这个问题也是我这段时间一直在思考或者说困惑的问题；</p>
<p>坦白说，目前做到当前的程度，个人其实是比较满意的，这期间花了很多很多的时间精力在工作上，在生活上面，泛善可陈，当然这里也有自己的原因，没有好好的去经营，但是不得不说，工作对于精力的消耗是巨大的，往往在有时间的时候，已经没有精力去更好的享受生活；</p>
<p>我一直认为，<strong>人没有上辈子，也没有下辈子，只有这辈子！一旦逝去，就是尘归尘，土归土，没有你，没有我，没有一切！</strong></p>
<p>所以，这辈子是不是一定要追求所谓的 <strong>成功</strong> ， 这个成功的定义是谁定义的？这里我会给自己打一个大大的问号！</p>
<!-- more -->
<p>结合前端时间跟领导汇报的工作来看，在后续的很长一段时间，我需要持续的去拔高自己的技术能力！但是这么多年经历下来，我比较明确自己的能力区间，在这一行里面，我可能在技术深度上面，目前已经到了没有太多提升空间的可能性的时候了，如果持续花更多的时间去钻研，这个边际效益怎么衡量？！</p>
<p>所以，我给自己定下来的目标是40岁退休，那么就要去计算，假设40岁退休，我需要多少的后备金去保证我的下半生的生活有一定的生活质量，以及未来我的退休生活应该是怎么样的？</p>
<h2>退休金计划</h2>
<p>衣食：
3万/月</p>
<p>住房：一次性支付
350万</p>
<p>行（旅游）：
10万/年</p>
<p>医疗： 重病由保险支付，门诊1万每年。超过部分由医保支付；
1万/年</p>
<p>家庭保险：重疾+中端医疗
10万/年</p>
<p>教育： （22年 * 10万每年  = 220万）
10万/年</p>
<p><strong>合计年支出：67万/年 * 110%（10%浮动支出） ～= 75万每年</strong></p>
<p>按照3%通胀计算，投资收益需要保证 收益 75万 且覆盖通胀，因此，总体需要：
5%投资收益： 2500万 + 350 万 - 100万(现有房产) ～= 4000万退休
6%投资收益： 1666万 + 250万 ～= 2750万退休
<strong>7%投资收益：  1250万 + 250万 ～= 2125万退休</strong>
8%投资收益： 1000万 + 250万 ～= 1750万退休
10%投资收益：715万 + 250万 ～= 1330万退休</p>
<p>按照目前沪深300长期复合投资收益率算，整体收益率大概在：7%左右，因此按照7%投资收益率计算fire目标，大概需要2125万退休，目前进度（20241008） ： <strong>3.2%</strong></p>
<h2>退休工作假想</h2>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/40"/><category term="生活感悟"/><published>2024-10-07T07:24:25+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/38</id><title>近期思考（20240918）</title><updated>2026-01-19T07:31:33.376030+00:00</updated><content type="html"><![CDATA[<p>最近这几周，项目上面放的太过了，整个团队的状态慢慢有点开始懒散，这跟预期已经开始有点背道而驰；问题在我，这两周对项目上面跟进的不够，给了大家过多自主的时间，而自己把过多的时间放在了AI learning上面，有点颠倒了主次；</p>
<!-- more -->
<p>所以，对于后续的工作、学习，应该还是要思考清楚，事情很多，不能够眉毛胡子一把抓，什么都想要的结果就是什么都拿不到；抓大放小才是主要的策略；那么现在看目前手上的事情，主要有几个：</p>
<ul>
<li>团队管理，核心团队的例会还是要开展起来，并且对今年下半年，着重要开始发展能力提升的事情以及重点工作的事情； 目前这部分已经停滞比较长的时间了；</li>
<li>串讲以及反串讲，这个要尽快，这两天要给出方案，提高团队的鲁棒性，增强抵抗风险的能力； 从预期上看，明年的361，还有10%的同学有可能会被汰换，涉及汰换的东西，要及时介入进去；</li>
<li>两个交付的项目上，第一个项目还是要尽快思考一下，下一步的方案，给出确定的解决措施；第二个项目做好监督；</li>
<li>AI learning每日的时间最多不能超过2小时，知识面上还要扩展一下，系统的把系统上的模块都了解一下；</li>
</ul>
<p>虽然张弛有度，但是团队还是要保持一种氛围，如果氛围被破坏了，再要重新建立起来，就会比较难了，所以在平时工作中，不能让自己成为了团队的关键路径，不要让自己成为阻塞团队发展的绊脚石，要把控好团队发展的方向，让大家动起来；</p>
<p><strong>重要的不紧急的事情，要坚持做！</strong>
<strong>重要且紧急的事情，要监督做！</strong>
<strong>紧急不重要的事情，要授权做！</strong>
<strong>不紧急不重要的事情，要放手做！</strong></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/38"/><category term="生活感悟"/><published>2024-09-18T02:16:23+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/37</id><title>始于颜值，忠于人品，陷于才华</title><updated>2026-01-19T07:31:33.496688+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<p>最近有人问了我一个问题，怎么看待爱情、婚姻以及家庭；三个词其实是递进的关系，从普世的价值观来看，有了爱情，进而有了婚姻，最后成立家庭；</p>
<p>但是分开来看，其实又有很多东西可以详细述说；与个人的认知、经历以及原生家庭强相关，所以要定义这三者，就要从这三个方面去看，否则只能管中窥豹，有失偏颇；</p>
<!-- more -->
<h1>爱情&amp;婚姻&amp;家庭</h1>
<p><strong>始于颜值，忠于人品，陷于才华</strong></p>
<p>我对于爱情、婚姻以及家庭的理解，可以从这句话开始； </p>
<p>最近在知乎上看到一个词，叫做<strong>生理性喜欢</strong>，我觉得这个可以等同于<strong>始于颜值</strong>；</p>
<h2>始于颜值</h2>
<p>GPT4中关于生理性喜欢的描述：</p>
<p><img src="https://github.com/user-attachments/assets/a1b8d4ac-95c8-47c6-875a-0f341cd81cfe" alt="生理性喜欢" /></p>
<p>简单来说，生理性喜欢更偏向于生物性本能，原始的倾向； 这个是第一性的原则；因为有了这个第一性的倾向，在后续的接触、交流以及认知后，慢慢填充以理性，最后判断这个人是否是正确的人；</p>
<p>甚至不可否认的是，每个人都会对很多相近的人都会产生生理性喜欢，这个是基因决定的； 女性慕强，男性慕色，这是由于几千年生存的基本本能，种族延续的要求，但是是不是所有有生理性喜欢的人都会走下去？这个就要看第二原则，人品或者人性；</p>
<p>此外，泛化来说，那比如我们父辈的感情，为什么也能持久？我理解他们大部分可能并没有始于颜值的生理性喜欢的冲动，那为什么有些人也能延续下去，并且相对的更稳定？</p>
<p>我觉得，可以类比于习惯，习惯的力量的是强大的，当在可接受范围内习惯了一个人之后，生物的趋同性会慢慢的发挥作用，这也是我们经常说，两口子在一起的日子长了，长相、行为、逻辑思维方式会越来越像的原因，通常意义上称之为夫妻相；并且有些人，可能因为年纪到了，找到一个人，开始以为将就着一起生活，但是慢慢的在一起后，也挺幸福，或许也是这个原因；</p>
<p>生理性喜欢或者颜值，通常还跟性相关；<em>床头打架，床尾和</em>，我认为这里也跟生理性喜欢强相关； 如果两个人之间已经冷淡到没有了生理性的冲动，夫妻生活，或者通常意义上夫妻生活和谐，也会伴随着很多的问题，曾经有过报道，无论男生、女生出轨，其中因为夫妻双方私密生活得不到满足，占据绝大部分原因，并且当婚姻走到了快结束的时候，往往双方已经没有了生理性喜欢，只是勉力的维持着双方的习惯；</p>
<p><strong>这也是我为什么一直坚持的原因，无论是始于颜值亦或者生理性喜欢或者是性，我认为第一性的生物冲动，决定了是否能够走下去的直接原因；</strong></p>
<h2>忠于人品</h2>
<p>人品我觉得可以分为两个方向去看，一个是对内，一个是对外：</p>
<ul>
<li>对内，主要是看这个人对待家人，对待爱人的品性；包含着耐心、忠贞；</li>
<li>对外，主要看这个人待人接物上是否苛刻，是否宽以待人，严以律己；</li>
</ul>
<h3>窝里横/伏地魔/凤凰男</h3>
<p>这里我特别提出了<strong>窝里横、伏地魔、凤凰男</strong>，因为这三者在对内上，有与常人非同一般的表现；</p>
<p><strong>窝里横</strong></p>
<p>可能不一定是夫妻，有可能这个角色是儿子亦或者父母，anyway，有些人在对外部的意见、问题、困难或者外人的要求上，总是战战兢兢，如履薄冰的完成，但是对内，却总是各种苛刻，各种要求；外人的意见或者想法永远大于自己人，跟这样人品的人在一起，或者作为其家人，总会感觉一种特别的无力感，因为你的所作所为，你的努力在他看来，甚至没有外人的一句话重要，你的付出，他完全也看不到；</p>
<p><strong>伏地魔</strong></p>
<p>事实上，伏地魔只是一类表现，我认为统一叫做<strong>屁股坐歪了</strong>， 在没有成婚之前，我理解你是归属于整个大的家庭里面的，但是当一段婚姻或者感情落地的时候，已经独立出一个小家，这个时候，如果屁股还坐在原生家庭里面去考虑问题，很可能就会把小家拆散；我始终认为，只有先把小家处理好了，犹有余力，才能去帮助大家；</p>
<p>这里也可以谈到<strong>彩礼</strong>， 我觉得女生要彩礼，为了为未来的生活做最坏的考虑，这笔钱可以存起来或者可以投资等等，当女生的婚姻或者小家出现问题的时候，可以拥有一定的底气，毕竟这个可以算作婚前财产； 所以，当这笔钱如果最后是放在女生的手里的时候，我认为这个彩礼应该出，甚至多出一点也正常，因为这个可以叫做个人或者家庭<strong>风险防范金</strong>；但是假设这笔钱是落到了其父母手中，或者是其他人手中，我认为这个钱一分都不应该出；</p>
<p><strong>凤凰男/凤凰女</strong></p>
<p>几年前流行凤凰男/凤凰女这个词的时候，我还特意比较了一下自己，看看是否有凤凰男的表现，凤凰男的表现一般有几种：</p>
<ul>
<li>自卑又自负</li>
<li>敏感又多疑</li>
<li>大男子主义又没有能力</li>
<li>愚孝，甚于妈宝男</li>
<li>特别爱面子</li>
<li>斤斤计较</li>
</ul>
<p>嗯，所以避之不及吧~~</p>
<p><strong>总结一下</strong>， 我理解忠于人品，是说<strong>双方对彼此的信任</strong>，包含了各自的性格，为人处事；</p>
<h2>陷于才华</h2>
<p>我们把才华拆解成两个方向，一个是情商，一个是智商；</p>
<p>简单粗暴的理解，智商衡量的是工作上赚钱的能力，生活上解决问题的能力；情商衡量的是双方能否互相体谅，能否满足双方情感需求，能够给到足够的情绪价值；</p>
<p><strong>智商</strong></p>
<ul>
<li>赚钱的能力 ： 物质基础决定上层建筑，贫贱夫妻百事哀；我觉得是有一定道理的，我不太相信<em><strong>有情饮水饱，无情金屋寒</strong></em>这句话；所以我理解双方都要有一定赚钱的能力； 当然，这个也是存在一定边际效益的，我理解，不能为了赚钱而赚钱，而是在一个边际效应与投入的最佳的比例上。至于这个比例，更多是双方的需求以及对未来的规划上；</li>
<li>解决问题的能力：生活上会出现很多的问题，有些人在生活上就像巨婴，没有自己的动手能力，无论是装修、买房或者等等其他的事情，完全依赖另外一方或者父母，这样的感情，对于另外一方长久之后，有可能会形成累赘；</li>
</ul>
<p><strong>情商</strong></p>
<ul>
<li>情绪价值：我觉得这个很重要，嗯，非常重要； <strong>情绪价值，情绪价值，情绪价值</strong>，我们既要有能够感知对方情绪需求的能力，也要有提出需要情绪价值的能力；很多时候，<strong>大家都关注在要求对方感知自己情绪价值需求，而忽略了对对方主动提出情绪价值的需求的能力</strong>；读起来有点拗口，但是实际上非常关键； 对方能够感知你的需求，这当然另我们感动，但是主动提出需求，对方能够满足，一样是很重要的事情；</li>
<li>仪式感：生活需要仪式感，我们不要把两口子的生活过成了生存；事实上，推而广之，与父母相处，与子女相处，其实都是需要仪式感的，人的这辈子，就是由一个个关键的片段组成，生命中反反复复的日子我们能够记住多少，而有心的仪式感，反而让我们在过往之后，能够久久回味；</li>
<li>人情往来：老吾老以及人之老，幼吾幼以及人之幼；我们或许没有办法把对方的父母亲人完完全全当成自己的父母亲人，但是这个情商决定了，你能够做到什么程度，或者说，你能够做到让对方感知到什么程度；如何在日常的相处中，处理好各自家庭的情商能力，就非常重要了；</li>
</ul>
<p>综上，事实上，我理解爱情、婚姻、家庭是一以贯之的，保持初心，在开始的时候，看好你选择的人的人品、才华，最后步入婚姻，再到有了小孩的家庭，最后再到终老，也是从<strong>始于颜值，忠于人品，陷于才华</strong>中来的；</p>
<p><strong>且行且珍惜，但不将就！</strong>
<strong>边行边欣赏，仍持初心！</strong></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/37"/><category term="生活感悟"/><published>2024-09-12T07:10:03+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/36</id><title>AI 学习架构梳理</title><updated>2026-01-19T07:31:33.636789+00:00</updated><content type="html"><![CDATA[<h1>摘要</h1>
<p>最近要把AI 整体自底向上的梳理一遍，同时把自己的知识面好好扩充一下，因此需要整体的看看，主要有哪些东西，并且这些东西，应该从哪些地方去补充知识；</p>
<p>坦白说，这部分跟我自己以往的工作经历差别有点大，从通用服务器芯片的全栈，要转移到AI专用芯片的全栈，这个里面涵盖的知识面可能相对通用服务器要求的更高，所以这里可能近一年需要花比较多的功夫；</p>
<hr />
<p><strong>雄关漫道真如铁，而今迈步从头越</strong></p>
<hr />
<!-- more -->
<h1>详细对比</h1>
<p>几个关键点的主要差别：</p>
<ul>
<li><strong>芯片</strong> ： 需要了解当前业界的主要的AI芯片的架构分析以及总结，比如AMD、Nvidia、mobileeye、华为昇腾、特斯拉；</li>
<li><strong>底软</strong> ： 底软在服务器这边主要是底层驱动以及操作系统，这边由于是专用芯片，可能涉及到底层BSP的差异以及操作系统的差别，比如linux\qnx\lanting\rtos等</li>
<li><strong>编译器</strong> ：在服务器这边，其实大部分都是通用的gcc编译器，但是在AI这边编译器都是各不一样，但是大部分都是基于LLVM做后端+编译IR前端，这部分难度比较高，需要先大致了解，并且实操一下，才能有体感；</li>
<li><strong>编程框架</strong> ： 在服务器这边都是基于linux的编程框架，所以比较通用，不需要专门了解，但是在ＡＩ专用芯片上，针对编程框架，涉及到不同芯片的ISA、不同芯片的框架，比如pytorch、tersorflow、天工开物、mindspore等</li>
<li><strong>算法</strong> :  AI专用芯片的算法需要编程框架以及编译器支持，甚至芯片要特制化，所以理解算法的基础上，才能理解后端的设计原因；
<img src="https://github.com/user-attachments/assets/405f5c3a-1da5-4a42-917b-dd7259539a49" alt="AI系统架构图" /></li>
</ul>
<p><img src="https://github.com/user-attachments/assets/fe5b2204-1adb-4483-9395-21a3d1d75c2c" alt="AI系统" /></p>
<h2>行动项</h2>
<ul>
<li>梳理业界当前的AI\GPU 芯片的架构分析总结 --- 计划在9-10月底之前完成</li>
<li>在实验室中，搭建天工开物的实验室环境 --- 计划在9月底之前完成</li>
<li>《李宏毅的机器学习》课程 --- 计划9-10月底之前完成</li>
<li>《pytorch/tersorflow编程框架》 --- 计划11-12月底之前完成</li>
</ul>
<p>暂时先这么定，过程中，随时调整目标以及计划；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/36"/><category term="总结思考"/><published>2024-09-12T03:41:42+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/35</id><title>什么是卷积</title><updated>2026-01-19T07:31:33.753435+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<p>最近在看卷积神经网络，其中卷积这个词听过很多次，那究竟什么是卷积呢？</p>
<p>卷积的公式：
$$(f * g)g(x) = \int_{-\infty }^{\infty } f(t)g(x-t)dt $$</p>
<p>这里 $(f * g)g(x)$ 是什么意思？ $\int_{-\infty }^{\infty } f(t)g(x-t)$ 又是什么意思？dt 指带什么呢？</p>
<!-- more -->
<p><video src="[B站视频](https://www.bilibili.com/video/BV1VV411478E/?spm_id_from=333.337.search-card.all.click&vd_source=51d9e76fbae18dbbdbbf9aca57070f93)" controls="controls" width="500" height="300"></video></p>
<p>直接看视频吧 </p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1VV411478E/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d9e76fbae18dbbdbbf9aca57070f93">https://www.bilibili.com/video/BV1VV411478E/?spm_id_from=333.337.search-card.all.click&amp;vd_source=51d9e76fbae18dbbdbbf9aca57070f93</a></p>
</blockquote>
<p><img src="https://github.com/user-attachments/assets/e1ad4b56-42e7-4360-8cb8-b341b3e396a3" alt="图像卷积" />
CNN中卷积核相当于把g函数旋转了180度。</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/35"/><category term="读书笔记"/><published>2024-09-03T03:07:15+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/34</id><title>周总结及计划（20240902）</title><updated>2026-01-19T07:31:33.874821+00:00</updated><content type="html"><![CDATA[<h1>Summary</h1>
<p>上周发生的事情并不多，总结起来可以分为几件事情吧：</p>
<ul>
<li>项目上的事情，没有足够跟进</li>
<li>干部团建</li>
<li>锻炼及学习不足</li>
</ul>
<!-- more -->
<h2>项目</h2>
<p>目前看两个项目，小项目从目前看，CV投入的精力不会太大，主要还是尽快把大项目收尾吧，然后把自己的精力投入到相关业务、算法、编译器、工具链这一块，虽然没有打算在这个方向上面持续有太多的投入，但是还是需要知道这些相关的内容，细节有可能没有理解程度高，但是还是要手把手过一遍；</p>
<p>剩下的事情，主要还有几个：</p>
<ul>
<li>项目文档交付，本周每天私信催促一下，给出完成时间</li>
<li>问题单梳理，同样的，依次看一下</li>
<li>最后的执行情况，只剩下两三个人的事情</li>
<li>另外就是PG以及netlist的问题了</li>
<li>相关行动项跟之前的同时核对一下</li>
</ul>
<h2>干部团建</h2>
<p>本次干部团建去了庐山，这个完全破坏了庐山的印象，走马观花的看了一下，一个小溪流般的瀑布，山似乎也没有什么特别的，整体上印象不是特别好；</p>
<p>不过，团建完了一下德州，还挺有意思的，可惜现在似乎没有德州扑克相关的软件了，要不然可以再玩玩；</p>
<p>此外，干部团建跟老板散步聊了一下，差距能够很明显感觉到，曾经理已经能够掌控芯片的前后端交付，知识面以及能力，这一两年成长确实比较快，但是我还是限于CV，这里老板希望我往编译器、工具链、中间件、算法层面走一下，但是从我的认知来看，这里的水太深了，如果要去看技术细节，很难说能够跟做具体事情的同学相比，那么未来我应该怎么走？这个是最近这段时间我要好好想想的；</p>
<p>当然，从目前上来说，无论未来我要怎么走，关于业务、编译器、工具链、中间件、算法，从底向上要去学习，分析一下，路线可能有点像苏同学那样，往上层去走一走，不过这个的难度以及深度，需要自我把控一下，可能目前而言，我更多的要去把广度先填充起来吧；</p>
<p>先从<strong>know Why -&gt; Know How</strong>， 可能这个可以帮我在某种场景下走的更远；</p>
<p>另外，这次团建看了一下庐山会议的事情，对于红色的那段历史，突然挺感兴趣的，这个有时间可以看一下，连彭德怀这样的开国元帅，都能在政治斗争下，成为这样的牺牲品，可见政治斗争的残酷，对于这段历史其实也很好奇，像邓公、周恩来、叶剑英等等，都没有为其说话，任由功臣被批斗，可能或许我太过单纯了吧；</p>
<h2>锻炼及学习</h2>
<p>上周锻炼了两次，跑步还是没有，学习上呢，其实上周没有投入太多时间，感觉是不是想要做的太多了，时间上有点分配不过来了；还是要想想，是不是一周要做这么多事情；</p>
<h2>理财</h2>
<p>单独找时间要总结一下，<strong>为什么在理财上面会这么冲动？！！！</strong>，这个太不应该了，以后周中无论什么样，必须根据计划来，不能随意更改，随意买卖，宁愿少赚，也不能亏本；</p>
<h1>本周计划</h1>
<ul>
<li>
学习<ul>
<li>周阅读时间3小时  --- 《邓小平时代》</li>
<li>一集  李宏毅机器学习课程</li>
<li>一集  Python 机器学习课程</li>
<li>了解一下天工开物的工具链以及中间件，了解一下AI整体上下游软硬件配合的全流程，输出文档吧</li>
</ul>
</li>
<li>
锻炼<ul>
<li>跑步4次，20公里</li>
<li>健身房4次</li>
</ul>
</li>
<li>
工作<ul>
<li>项目TR4本周相关交付全部完成，收尾结束</li>
</ul>
</li>
<li>
生活<ul>
<li><strong>周末把生活上的事情处理一下，当断不断反受其乱，不能再拖下去了</strong></li>
</ul>
</li>
<li>
理财项目<ul>
<li>暂时没有时间投入开发</li>
</ul>
</li>
</ul>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/34"/><category term="周计划总结"/><published>2024-09-02T02:33:03+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/33</id><title>周总结及计划（20240826）</title><updated>2026-01-19T07:31:34.012954+00:00</updated><content type="html"><![CDATA[<h1>Summary and Plan</h1>
<p>上周似乎平平无奇，但是，但是，整体计划的完成率不到30%~~~</p>
<ul>
<li>backtrader的存储机制没有写完</li>
<li>乌合之众，没有看完，不过这么书准备放弃了，完全硬翻译过来的，看起来太痛苦了，换到《大钱细思》， 把这本书看完吧</li>
<li>跟老板汇报了一次，但是这次汇报，感觉到了压力，未来的路要想一想；</li>
<li>健身去了2次， 没有达标；</li>
</ul>
<!-- more -->
<p><strong>理财项目</strong></p>
<ul>
<li>完成量化交易mongodb的存储编码  ---  这个确实要抓紧了，已经两周没有进展了，本周需要确实的完成至少单线程存储；</li>
</ul>
<p><strong>阅读</strong></p>
<ul>
<li>本周《大钱细思》 看完吧</li>
</ul>
<p><strong>工作</strong></p>
<ul>
<li>梳理一下当下几个项目的交付策略，本周要制定下来 --- </li>
<li>项目上进行一下收尾，几个要交付的资料本周让大家动起来 --- 上周拖沓了，得尽快</li>
<li>长稳相关的工作也要开展起来
<em><strong>重复的故事，始终重复在发生</strong></em></li>
</ul>
<p><strong>AI算法</strong></p>
<ul>
<li>同样没有时间安排</li>
</ul>
<p><strong>运动锻炼</strong></p>
<ul>
<li>本周完成20公里的运动跑步 --- 坚持吧，我就不信完不成，早上不跑，就晚上跑，跑完再睡觉</li>
<li>控制一下饮食，保持大概4天的晚上不吃宵夜  --- 嗯，继续保持</li>
<li>力量训练保持4天完成吧  --- 上周完成了2/4，成绩有点差，本周估计要继续</li>
</ul>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/33"/><category term="周计划总结"/><published>2024-08-27T08:40:48+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/32</id><title>linux dma一致性分析</title><updated>2026-01-19T07:31:34.147397+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<p>在驱动的开发过程中，一般来说会涉及两部分的内存：</p>
<ul>
<li>描述符内存，数据量小，但是会比较频繁的跟CPU进行交互 </li>
<li>数据内存，数据量大，跟CPU交互的一次较少；</li>
</ul>
<p>在一般芯片架构设计以及软件设计上，对两者经常会有些特别不一样的处理，比如对于描述符的内存，是否需要IO去识别，并且主动推送到CPU cache中？ 又或者，对于数据内存，是否需要IO标记不冲刷系统SLC？等等，这里根据业务场景，行为模式的不同，会有一些区分；</p>
<p>同时，对于两块内存的申请，内核也会有特别的内存接口申请方式，一般来说，在内核驱动中，针对描述符内存，一般使用dma_alloc_coherent/dma_alloc_noncoherent接口，并且实际上，目前linux内核驱动，默认使用coherent接口，没有对描述符内存允许软件可配使用noncoherent接口；在处理数据内存的时候，一般使用dma_map_single/dma_pool的方式申请，并且可以选择由硬件维护一致性或者软件维护一致性；</p>
<!-- more -->
<h2>一致性</h2>
<p>这里针对一致性稍微做一下解释，这里说的一致性指代的是外设跟CPU看到的内存数据是否是一致的，跟cache无关； </p>
<p>比如说，假设映射的内存是Cacheable的，只要CPU跟IO 在Cache中看到的数据是一致的，无论这个数据在硬件架构设计中，是如何保证看到的一致都可以；同样的，假设映射的内存是NonCacheable的，CPU跟IO外设看到的数据在DDR中都是一致的即可；</p>
<p>当然，这里说的更多的是硬件去维护了数据的一致性，也可以由软件去维护，比如大部分情况下，描述符内存支持软件去维护一致性；</p>
<blockquote>
<p>最近团队看到一款芯片，似乎存在一致性的问题，这个问题比较有意思，我会单独以另外一篇文档去分析该问题，在有些架构设计的时候，需要特别注意；</p>
</blockquote>
<hr />
<h1>代码分析</h1>
<h2>描述符内存</h2>
<pre><code class="language-c">//dma_alloc_coherent -&gt; dma_alloc_attrs -&gt; dma_direct_alloc 

void *dma_direct_alloc(struct device *dev, size_t size,
                dma_addr_t *dma_handle, gfp_t gfp, unsigned long attrs)
{
        bool remap = false, set_uncached = false;
        struct page *page;
        void *ret;
		
    	... ...

        /* we always manually zero the memory once we are done */  ---&gt;  (1)
        page = __dma_direct_alloc_pages(dev, size, gfp &amp; ~__GFP_ZERO, true);
        if (!page)
                return NULL;

        ... ...
            

        if (remap) {
                pgprot_t prot = dma_pgprot(dev, PAGE_KERNEL, attrs);   ---&gt; (2)

                if (force_dma_unencrypted(dev))
                        prot = pgprot_decrypted(prot);

                /* remove any dirty cache lines on the kernel alias */
                arch_dma_prep_coherent(page, size);   ---&gt; (3)

                /* create a coherent mapping */   ---&gt; (4)
                ret = dma_common_contiguous_remap(page, size, prot,   
                                __builtin_return_address(0));
                if (!ret)
                        goto out_free_pages;
        } else {
                ret = page_address(page);
                if (dma_set_decrypted(dev, ret, size))
                        goto out_free_pages;
        }

        memset(ret, 0, size);
		
    	... ...

        *dma_handle = phys_to_dma_direct(dev, page_to_phys(page));
        return ret;
    
    	
    	
</code></pre>
<p>这部分代码主要的过程描述如下：</p>
<ul>
<li>
<p>（1）通过__dma_direct_alloc_pages申请内存，并且将这部分page的内容清0，为了加快速度，内核默认情况下，都是申请的cacheable的内存，在内核启动过程中，默认将大部分的内存都通过线性映射的方式建立了映射关系；所以在该接口中，只是从软件管理的page内存池中获取对应大小的page，并不会建立页表真实的entry，这部分entry早就建立完成；</p>
</li>
<li>
<p>（2）这里是获取后续需要重新remap的时候，建立的页表属性；</p>
</li>
</ul>
<pre><code class="language-c">  
  pgprot_t dma_pgprot(struct device *dev, pgprot_t prot, unsigned long attrs)
  { 
          if (dev_is_dma_coherent(dev))   ---&gt; 如果dts传入dma-coherent 标志，则使用cacheable的属性（由外部传入）
                  return prot;
  #ifdef CONFIG_ARCH_HAS_DMA_WRITE_COMBINE
          if (attrs &amp; DMA_ATTR_WRITE_COMBINE)
                  return pgprot_writecombine(prot);
  #endif
          return pgprot_dmacoherent(prot);  ---&gt; 否则这里就是用noncache的属性
  }
  
  
  #define pgprot_dmacoherent(prot) \
          __pgprot_modify(prot, PTE_ATTRINDX_MASK, \
                          PTE_ATTRINDX(MT_NORMAL_NC) | PTE_PXN | PTE_UXN)
</code></pre>
<ul>
<li>（3）这里特别注意alias， 因为内核在初始的时候有初始化过系统的页表，也有可能当前这块空间之前有人使用过，假设是cacheable属性的，需要保证这块内存的数据已经完全刷入到PoC点，所以这里在申请到的时候，先对这块page进行flush动作</li>
</ul>
<pre><code class="language-c">void arch_dma_prep_coherent(struct page *page, size_t size)
{
        unsigned long start = (unsigned long)page_address(page);

        dcache_clean_poc(start, start + size);
}
</code></pre>
<ul>
<li>（4）dma_common_contiguous_remap开始设置具体的页表项PTE等</li>
</ul>
<p>可以看到，大部分的驱动实际上在描述符内存的应用上，都是使用的coherent的方式，要么都是cacheable，由硬件维护一致性，要么都是noncacheable，数据直接到DDR中，这样也能保持一致性（这个应该是底线要求，也是驱动默认的使用dma_alloc_cohorent接口的原因）；</p>
<p>当然可能有些系统，处于某种原因，需要使用dma_alloc_noncoherent接口，这个时候就需要主动去维护一致性，在使用描述符内存的时候，在软件中，主动进行刷的动作，具体操作可以跟数据内存方式一致；</p>
<h2>数据内存</h2>
<p>一般来说数据内存一般使用dma_map_single/dma_unmap_single的方式申请/释放，并且该接口支持一致性的维护：</p>
<ul>
<li>设备在map page的时候，需要将CPU这段空间的数据刷到PoC点（point of coherent），保证最新的数据已经到一致性节点处；</li>
</ul>
<pre><code class="language-c">//dma_map_single -&gt; dma_map_page_attrs -&gt; dma_direct_map_page

static inline dma_addr_t dma_direct_map_page(struct device *dev,
                struct page *page, unsigned long offset, size_t size,
                enum dma_data_direction dir, unsigned long attrs)
{
    
        ... ...
        
        if (!dev_is_dma_coherent(dev) &amp;&amp; !(attrs &amp; DMA_ATTR_SKIP_CPU_SYNC))
                arch_sync_dma_for_device(phys, size, dir);
        return dma_addr;
}

</code></pre>
<p>当然如果设备加了dma-coherent标签，表示硬件支持一致性维护，这里就不需要主动进行刷的动作</p>
<ul>
<li>设备在unmap page的时候，需要CPU invalid cache，保证从DDR中获取设备更新的数据；</li>
</ul>
<pre><code class="language-c">static inline void dma_direct_unmap_page(struct device *dev, dma_addr_t addr,
                size_t size, enum dma_data_direction dir, unsigned long attrs)
{
        phys_addr_t phys = dma_to_phys(dev, addr);

        if (!(attrs &amp; DMA_ATTR_SKIP_CPU_SYNC))
                dma_direct_sync_single_for_cpu(dev, addr, size, dir); ---&gt; invalid cache

    	... ...
}
</code></pre>
<h1>其它</h1>
<p>在有些CPU架构里面，会对描述符内存或者数据内存做一些额外的处理，用来提升整体IO的性能，一般常见的几种特别的做法是：</p>
<ul>
<li>支持标记描述符内存的地址，主动push到对应核的cache中，提升CPU与外设交互的性能</li>
<li>支持标记数据内存的范围，比如像在网口中，前面的64字节内存push到cache中，后面的数据不存放cache，避免冲刷其它业务cache，导致性能下降，前面64字节是网络报文头经常处理的，需要与cpu频繁交互，在cache中可以提升CPU交互的性能</li>
<li>支持数据内存的filter功能，比如特定长度的数据内存可以支持乱序，特定长度的内存需要保序，这个在PCIe 的网卡中比较常见</li>
<li>......</li>
</ul>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/32"/><category term="总结思考"/><published>2024-08-27T06:37:18+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/31</id><title>《华为高绩效管理PBC：上下同欲/力出一孔》</title><updated>2026-01-19T07:31:34.287633+00:00</updated><content type="html"><![CDATA[<h1>《华为高绩效管理PBC：上下同欲、力出一孔》</h1>
<p>这本书主要讲怎么通过PBC进行团队的管理，以达到团队的高绩效，其根本核心是打造一个<strong>上下同欲、力出一孔</strong>的文化价值观以及绩效导向；</p>
<!-- more -->
<p><strong>概念解释</strong></p>
<p>什么是<strong>绩效考核</strong>？ 什么是<strong>绩效管理</strong>？</p>
<p>书中有一些话对二者进行了一些描述：</p>
<blockquote>
<ul>
<li>每人以自己为标准，不断地把今天与昨天比，从而推进个人与企业的进步。</li>
<li>绩效是指员工在履行岗位职责或角色要求的过程中所表现出来的行为（How）和达成的贡献结果（What）</li>
<li>华为的绩效定义中分别提到了What和How。What是做了什么，是具体成果、绩效的结果，是落后指标。How是怎么做，是其他影响结果的因素，如心态、行为、能力、方法，是领先指标。</li>
<li>绩效管理不仅强调结果导向，而且重视实现目标的过程。</li>
<li>绩效管理重视过程、控制过程，过程是保证。绩效考核重视结果，突出绩效以结果为导向</li>
<li>绩效考核的重点是过去，绩效管理的重点是未来，这是二者最大的不同。</li>
</ul>
</blockquote>
<p><img src="https://github.com/user-attachments/assets/e9225ede-2cc0-4290-b392-73c6cc42c85b" alt="绩效管理与绩效考核的差别" /></p>
<p>简而言之，我认为绩效考核是绩效管理的其中一个环节，没有考核就只有过程管理是没有结果，只有过程管理，没有考核就不能激活组织！</p>
<p><strong>文化价值观牵引</strong></p>
<p>在绩效管理的过程中，需要重点管理过程中体现出的文化价值观，<strong>价值至上、结果为王</strong>；</p>
<blockquote>
<ul>
<li>所谓相对评价，就是在同等条件（企业投入的资源）下，看谁的产出更大</li>
<li>绩效管理不只是绩效目标设置和输出，而是要落实到<strong>目标设定、过程辅导、绩效评价和结果反馈</strong>四个环节，对四个环节不断强化牵引方向和纠正偏差，从而牵引团队和个体朝着正确的方向迈进，让价值评价的结果体现价值创造的贡献</li>
</ul>
</blockquote>
<p><strong>绩效管理工具 ： PBC</strong></p>
<blockquote>
<ul>
<li>第一个方面是承诺赢（Win），员工承诺本人在考核期内所要达成的绩效目标与结果，以支持部门或所在组织总体目标的实现。</li>
<li>第二个方面是承诺执行（Execute）， 言必行，行必果，为达成绩效目标，员工与考核者对完成目标的方法及执行措施达成共识，并将执行措施作为考核的重要部分，以确保目标与结果的最终达成。</li>
<li>第三个方面是承诺团队（Team），为保证团队整体绩效的达成，更加高效地推进关键措施的执行和目标、结果的达成，被考核者需要对交流、参与、理解和相互支持等团队管理的诸多方面进行承诺</li>
</ul>
</blockquote>
<p>这里需要引导牵引，PBC只是一个工具，更多的要落实在过程中：</p>
<blockquote>
<ul>
<li>引导并激励员工贡献于组织的战略目标，同时实现组织和个人的共同成长，它不只是绩效考核，更是一个系统的管理过程</li>
<li>我是谁？在组织定位和流程中扮演的角色。</li>
<li>做什么？工作范围、对象、流程，从事的任务和活动。</li>
<li>担什么责？必须取得的成果的关键领域。</li>
<li>有什么能力要求？从事该岗位需要的知识、技能和经验</li>
</ul>
</blockquote>
<p><img src="https://github.com/user-attachments/assets/9cc9fc5a-9532-4d44-a1bf-16bb2afe6fa5" alt="PBC四部曲" /></p>
<p>四个步骤：</p>
<ul>
<li>目标制定 ： 这里需要结果员工的能力、级别以及定位，制定相应的目标，对于高级别的同学，应该给与更大的空间以及挑战，并且做好价值观的匹配，这里非常容易出现问题，要么是制定的目标跟员工无法达成一致，要么是员工制定的目标过于简单，导致在最后绩效评定以及结果反馈的时候出现问题；所以这里可能之前做的并不是太严谨，需要再思考一下；</li>
<li>过程管理：这里其实是做好预期管理，这个很重要，对于识别出绩效风险的同学要提前做好平时的期中管理，避免出现<strong>惊喜</strong>；</li>
<li>绩效评定：员工对年度工作表现的自我总结；主管对员工全年工作进行评价；<strong>作为主管，平时工作的时候，要下意识的记录一些关键事件，做的好的，做的不足的要有事实依据</strong></li>
<li>
结果反馈： 绩效沟通大致总结一下，可以按照如下套路来：<ul>
<li>先让同学自我总结一下去年整体的输出，以及自我识别出有待改进的地方</li>
<li>首先不管绩效好坏，<strong>要先识别员工做的好的地方，这个非常重要！！！！<strong>没有任何人喜欢一上来就说不足，都喜欢得到肯定！说话的方式不要直接说哪哪哪做的不好，而更应该以</strong>建议</strong>、<strong>希望</strong>、<strong>是不是</strong>等语气表达预期；</li>
<li>如果有强事实依据的，直接根据事实提出改进意见，对于有灰度绩效的地方，更重要的是提出要求，避免跟同学沟通上陷入到咬文嚼字，扣PBC具体的落地情况上；</li>
<li>不要推卸责任，管理者担责，要敢于管理，对于高级别的同学，不要害怕人员流失，要大胆的提出对应级别的要求以及对他的期望；如果实在无法达成一致意见的，可以行驶行政权力，绩效沟通不要陷入了希望对方认同结果的陷阱里面，要多谈论要求以及期望，对于过去的结果，只是过去的快照，如果员工一直陷于过去，直接点明，价值观无法达成一致的员工，可以给与他选择的权力</li>
</ul>
</li>
</ul>
<p><strong>PBC绩效沟通</strong></p>
<blockquote>
<ul>
<li>阅读之前设定的工作目标。</li>
<li>检查每个目标完成的情况。</li>
<li>从员工的同事、下属、客户、供应商处了解详情。</li>
<li>搜集关于该员工工作表现的情况。</li>
<li>对于出现高分和低分的目标要搜集翔实的资料。</li>
<li>整理该员工的表扬信、感谢信、投诉信等。</li>
<li>为下一阶段的工作设定目标。</li>
<li>提前一星期通知员工做好准备。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>提供绩效记录，以便决策。</li>
<li>尽早发现潜在问题，帮助员工改进。</li>
<li>发现员工的长处，以便进一步培养和利用。</li>
<li>对工作出色的员工加以表扬，以提高员工的积极性。</li>
<li>收集解决问题所需的充足、准确的信息。</li>
<li>记录有关绩效沟通的详细情况，以便在进行纪律处分和处理潜在的法律诉讼纠纷时使用。</li>
</ul>
</blockquote>
<p>整体来说，管理过程中，还是要做好相关关键事件的准备，以备沟通有理有据！</p>
<blockquote>
<p>① 鼓励员工的参与。</p>
<p>② 认真聆听员工的看法和意见。</p>
<p>③ 关注员工的长处。</p>
<p>④ 谈话要具体，使用客观化的词句。</p>
<p>⑤ 保持平和的态度。</p>
<p>⑥ 谈话是双方的沟通而非演讲。</p>
<p>⑦ 不做假设和提前判断。</p>
<p>⑧ 简单地总结一下对员工的总体评分或评价。</p>
<p>⑨ 讨论评语对双方的意义。</p>
<p>⑩ 认真聆听，以积极的态度结束讨论。</p>
<p>绩效沟通要做到激励员工改进，帮助员工成长。主管应牢记“<strong>给依据、说优势、有期待</strong>”九字真言，让绩效沟通言之有物，有理有据。绩效沟通说难也不难，关键在于主管是否用心和践行。当然，在绩效沟通过程中，尊重、坦诚和同理心等人际互动的基本准则也是应当遵守的</p>
</blockquote>
<p><em>在坚持核心价值观的前提下，灵活应用“<strong>开放、妥协、灰度</strong>”，是激发高绩效团队的关键调节手段。如何基于全局观和业务实质，通过正确理解并应用“开放、妥协、灰度”，充分调动团队每个成员的主观能动性，激发全员奋斗精神，牵引价值创造，是作为主管需要重点思考的问题。</em></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/31"/><category term="读书笔记"/><published>2024-08-20T13:24:05+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/30</id><title>周总结及计划（20240819-20240825）</title><updated>2026-01-19T07:31:34.434368+00:00</updated><content type="html"><![CDATA[<h1>Summary and Plan</h1>
<p>总体来说，上周发生了比较多的事情，感觉到心累！！可是，日子还要过下去；
很多时候，工作事情容易处理，生活的事情却难以抉择，无论是面对即将汰换的老员工，还是斩断三千烦恼丝，都是一件让人前后纠结的事情；
清官难断家务事，或许便是如此；</p>
<p>上周解决了一个裁员的大难题，团队整体看，没有我想象的那么悲观，真的在沟通的那一刻，又好像水到渠成，一切似乎都那么平静，这个倒是了却了我的一大心结；</p>
<!-- more -->
<p>项目上，上周还有较多的事情没有完成，这个怪我，没有支棱起来，上周萎靡了一周，没有太过于关注项目的进展，导致整体的进展实际上跟预期相差较大，本周这里需要更激进一点，跟的不紧，很多事情就会跟丢了；</p>
<p>分开几个事情看一下，整体目标没有达成预期，相差的还有不少距离：</p>
<p><strong>理财项目</strong></p>
<ul>
<li>完成量化交易mongodb的存储编码  --- 看起来还是没有完成，基本没有任何投入，主要是周末两天有生活上的安排，导致没有投入，这个本周还是要花一些时间在里面的，完成存储部分，不能一直拖着</li>
</ul>
<p><strong>阅读</strong></p>
<ul>
<li>华为的绩效管理书是看完了，但是留的印象不多，需要做一下总结，这个本周完成</li>
<li>心理学相关的书籍，还是要看一下，本周《大众心理学》 看个一半吧</li>
</ul>
<p><strong>工作</strong></p>
<ul>
<li>绩效沟通完成几个TL以及关键人物的沟通 --- 本周持续进行，完成整个绩效的沟通，同时辅助新进小组长完成他们团队的一次沟通；</li>
<li>整体的验证策略好好梳理一下，解决掉尾巴问题 --- 这个本周要内部评审一下几个项目的策略，包括自己也要好好梳理一下，还是有点混乱</li>
<li>项目上进行一下收尾，几个要交付的资料本周让大家动起来</li>
<li>长稳相关的工作也要开展起来
<em><strong>o(╥﹏╥)o，感觉上周什么事情也没有做一样，白混过去了，得检讨一下自己</strong></em></li>
</ul>
<p><strong>AI算法</strong></p>
<ul>
<li>上周没有投入，这周末有一些安排，估计很难投入，先pending</li>
</ul>
<p><strong>运动锻炼</strong></p>
<ul>
<li>本周完成20公里的运动跑步 --- 上周完全荒废，这周早起跑吧，试试早上跑完一整天累不累</li>
<li>控制一下饮食，保持大概4天的晚上不吃宵夜  --- 嗯，继续保持</li>
<li>力量训练保持4天完成吧  --- 上周完成了1/4，成绩有点差，本周估计要继续</li>
<li>体侧结果有点差呀， 32.8%的体脂，比原先估计的还要多，坚持一个月晚上不吃碳水；
<img src="https://github.com/user-attachments/assets/a9b7eda8-0658-476f-9832-ae213e4b6af7" alt="20240819体测结果" /></li>
</ul>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/30"/><category term="周计划总结"/><published>2024-08-19T03:28:08+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/29</id><title>生活的懈怠之本周计划(20240812)</title><updated>2026-01-19T07:31:34.564488+00:00</updated><content type="html"><![CDATA[<p>最近这一个月，工作以及生活上有些懈怠~~~
不想工作<del>
不想学习</del>
不想理财<del>
也不想游戏</del>
就是看看小说，刷刷抖音，似乎也过去了，还有偷偷打个麻将~</p>
<!-- more -->
<hr />
<p>这一周周一，一天开了几个会，突然间发现已经有些跟不上了，好几个问题的定位分析，已经有点深入不进去，开始慢慢掉队了；
感觉这是一个危险信号，是不是在这个位置上就开始躺平了，明明自己知道，在好几个地方，都还没有实际上做出成绩，收入也才刚刚完成负债收敛，这个时候，才正式开始积攒家底的时候，不应该这个时候就开始松懈；</p>
<p>想想还是给自己立一些flag，先不说远的，从周计划开始吧，做做周计划，搞搞周总结，人嘛，还是要有一些约束以及奔头的，给自己找点事情做吧；</p>
<p><strong>理财</strong></p>
<ul>
<li>本周完成量化交易mongodb的存储编码，至少可以将远端数据存储起来，先不讲究通用性，先把可用解决吧，后续有时间再解决扩展问题，估计也就自己用，无所谓了；</li>
</ul>
<p><strong>阅读</strong></p>
<ul>
<li>看完一本绩效相关的书籍吧，整理一篇相关的读书笔记吧</li>
</ul>
<p><strong>工作</strong></p>
<ul>
<li>绩效沟通完成几个TL以及关键人物的沟通</li>
<li>整体的验证策略好好梳理一下，解决掉尾巴问题</li>
<li>项目上进行一下收尾，几个要交付的资料本周让大家动起来</li>
<li>长稳相关的工作也要开展起来</li>
</ul>
<p><strong>AI算法</strong></p>
<ul>
<li>再推进5节课程吧，整体上输出两三篇学习笔记吧</li>
</ul>
<p><strong>运动锻炼</strong></p>
<ul>
<li>本周完成20公里的运动跑步</li>
<li>控制一下饮食，保持大概4天的晚上不吃宵夜</li>
<li>力量训练保持4天完成吧</li>
</ul>
<p>等到周五看看本周的总结的完成情况，再去制定下周的计划~~~</p>
<p>还是要往前push自己一下，现在还不到躺平的时候，或许明年可以吧，慢慢来~~</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/29"/><category term="周计划总结"/><published>2024-08-12T11:48:23+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/28</id><title>高级别同学的汰换沟通策略梳理</title><updated>2026-01-19T07:31:34.682349+00:00</updated><content type="html"><![CDATA[<p>最近团队内给了一个高级别，并且是业务团队的小主管打了一个M-的绩效，按照公司要求，打了M- 的同学会被公司辞退；那么怎么样跟这个同学沟通，能够尽可能减小的对整个部门的影响，这是我这两周以来一直在思考的问题~</p>
<!-- more -->
<p>坦白说，当时整个部门分成了5个小的业务团队，在我空降这个部门任职部长的时候，这个同学是最为配合工作的一个主管，我花费的沟通成本是最低的；</p>
<p>但是从实际的这两年的共同工作来看，这个同学有一个比较明显的问题，可能也是工作那么多年以来的习惯，很多事情吩咐下去，虽然口头上不会反驳一点，但是实际在完成这件事情的时候，会有一大堆的问题以及理由告诉你，这件事做不到；这个在我的职业生涯里面，其实是很难以接受的，因为对于高级别的同学，其实要求的是问题的解决能力以及规划能力，并不是执行能力；对于部门的业务方向上的事情，需要有自己的解决策略，而并不是每次面对事情的时候，先给我抛出一大堆的困难，然后告诉我，这件事情很难做；</p>
<p><strong>我们评价一件事情要不要做，不是看这件事情难不难做，而是看这件事做了有没有必要，如果有必要，能够带来收益，就是再难，也要做成，如果没有必要，再简单也不用做！</strong></p>
<p>当然了，现在的问题已经不是评价这位小主管了，而是更多的思考如何减小汰换的影响，那么我们首先要考虑的主要有几个方面：</p>
<ul>
<li>部门其它TL的感官以及影响</li>
<li>小团队内其它骨干的影响</li>
<li>面对面沟通策略，他本人的应激反应以及可能的舆情</li>
<li>如何通过这个事情达到激发的目的</li>
</ul>
<p>所以针对上面的几个问题，具体在沟通之前需要完成以下这些事情，做好相关的预案。</p>
<hr />
<p>1、<strong>小团队其它成员的影响</strong></p>
<ul>
<li>借助绩效沟通的环境，识别可能得风险，提前安排相关骨干进行干预，同时做好绩效考核导向的要求，让同学理解绩效考核的目标；</li>
<li>目前看最可能有影响的是跟随一起进来的同学，需要做好随同离职的准备，目前其工作替代的可能性较高，风险较小；</li>
</ul>
<p>2、<strong>其它小团队主管及核心骨干的感官</strong></p>
<ul>
<li>需要跟其他小团队的主管进行提前沟通，做好他们自己团队内风险识别以及舆论识别，这个可能优先级排在第二；</li>
<li>部分核心同学也需要做好1对1的沟通，避免引起群体事件；</li>
<li>也通过这个事情，对相应的TL面前树立自我的威信以及提供警醒；</li>
</ul>
<p>3、<strong>其本人的沟通策略</strong></p>
<ul>
<li>首先让该同学自我描述一下上半年的整体输出，然后从绩效事实上面点评整体的问题；一定要做好事情的绩效梳理工作；</li>
<li>该同学肯定会不认同当前的绩效结果，需要收集相关的绩效事实，同时不强求必须认同该绩效结果，价值观方面的差异是很难对齐的；</li>
<li>如果该同学有过激的反应，在沟通过程中，及时让HR同学介入，沟通离职相关事宜；</li>
<li>部门方面做冷处理，不谈论该名同学的离职；但是在部门的大会上面，对于绩效考核的要求再次跟大家明确；</li>
<li>做好沟通时候的录音，只对事不对人，表达要求以及客观事实；</li>
</ul>
<p>4、<strong>如何通过这个事情达到激发的目的</strong></p>
<ul>
<li>本月的大会上面，需要重点就 <strong>绩效考核以及绩效导向</strong> 来给大家讲一下相关的事情，需要明确一下，什么是我们团队的价值观，对于低级别的同学以及对于高级别的同学的要求是什么，给大家把一些标准确定下来；</li>
<li>其次今年的重点工作的事情也需要让大家知道，给大家明确一下大家在不同工作领域里面应该如何做到极致，如何体现出自己的价值；</li>
</ul>
<hr />
<p>实际在职场中，汰换、离职是非常正常的，特别是在一些竞争激烈的行业里面，如果找不准自己的位置以及无法体现出自我的核心价值，是非常容易被汰换的；
无论做什么事情，都要去思考一下，我如果做了这件事，我如何能够体现出我跟别人做的不一样的地方，无论是效率、结果还是方式，如果跟别人做不出差别，或许下一个被替代的就是自己；
与君共勉！</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/28"/><category term="生活感悟"/><published>2024-08-12T05:58:01+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/27</id><title>目标140斤以内，是不是3个月内可实现的？</title><updated>2026-01-19T07:31:34.823067+00:00</updated><content type="html"><![CDATA[<p>谈减肥谈了很多次了，包括在朋友圈晒目标，跟朋友下决心，等等，经历过很多次，但是最终都失败了，似乎一直处于&quot;<em><strong>下决心，开始控制饮食+运动，然后中途放弃，最后又开始下决心</strong></em>&quot;的怪圈，始终无法彻底走出来；</p>
<p>所以，我们需要仔细分析一下，这个项目应该要怎么做？</p>
<!-- more -->
<h1>项目分解</h1>
<p>项目的目标很明确，减脂（不是减重），所以一开始说订立140斤的减肥目标其实是有误区的，应该说从将近30%的体脂率，减到一个正常的体脂率，那么正常偏低的体脂率，应该是多少呢？查了一下网图：
<img src="https://github.com/user-attachments/assets/a6e9911e-55f7-4539-8695-a035494a175b" alt="不同的体脂率" /></p>
<p>从上图的表现看，比较倾向的体脂率是大概：15%左右，所以取值15%作为减脂的目标；</p>
<p>那么按照15%的体脂，需要减脂多少g的脂肪呢？</p>
<p><img src="https://github.com/user-attachments/assets/d172e09c-6773-401b-9c2f-884d193181eb" alt="体脂公式" /></p>
<p>从这个公式中，我们将15%的体脂率带入，可以计算到：</p>
<p>目标脂肪含量为： <strong>9kg</strong>；
当前脂肪含量为： <strong>25.5kg</strong>
<strong>所以理论上需要减去脂肪约16.5kg，33斤，所以当前体重为： 170斤，目标体重为137斤；</strong></p>
<p>按照当前基础代谢计算，每天的热量缺口按照500大卡计算（假设全部脂肪供能），<strong>500卡路里相当于55克左右的脂肪</strong>，那么要达到16.5kg的总量，需要时间为： <strong>10</strong>个月;</p>
<p>所以正确的目标应该是： </p>
<p><strong>在10个月以内，体脂率从30%降低到15%，脂肪减去16.5kg， 每天至少保持500大卡的热量缺口！</strong></p>
<p>所以，尝试按照现在正常的目标进行减脂，最后，我们10个月后，看看效果；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/27"/><category term="生活感悟"/><published>2024-08-08T08:34:05+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/26</id><title>美股大跌，A股是跑路还是加仓？</title><updated>2026-01-19T07:31:34.961505+00:00</updated><content type="html"><![CDATA[<p><img src="https://github.com/user-attachments/assets/c0bf3d12-56c7-4a2b-98e3-bf27d3146dae" alt="美股大跌，A股跑路还是加仓？！" /></p>
<!-- more -->
<p><img src="https://github.com/user-attachments/assets/7f11ab86-1155-4844-8442-de8b21b74348" alt="美股大跌" /></p>
<p>这两天美股因为就业数据的问题，引起了机构对于投资美国的经济的担忧，导致美股大跌，那么对于A股是不是像上面说的，要赶紧跑路，因为从之前的情况来看，<strong>美股大涨，A股小涨，美股小跌，A股大跌</strong>；</p>
<p>但是从我的角度，当然目前只是感性的猜测，这几年美股加息，美元回流，推高了美股股市，在目前的全球政治局势下看，欧洲已经有点停滞不前了，中东战争进一步恶化的情况下，欧洲影响可能更大；目前可以容纳资本的，或许A股、港股是一个比较好的地方，虽然国内的经济数据也不好看，但是整体上，目前还能过得下去； 所以国内重仓高息分红的银行，我认为是比较保险的避险资产； </p>
<p>另外，想说的是，尽管这两天美股、日经都是暴跌，但是A股还相对稳定，略跌一点，说明A股当前已经走出了部分独立行情；此外，人名币快速升值，也是提供了美元回流的一大理由；
<img src="https://github.com/user-attachments/assets/cf47da39-7fb5-46c3-8c21-6ed71e6d3d0b" alt="人名币升值" /></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/26"/><category term="投资交易"/><published>2024-08-05T11:20:19+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/25</id><title>关于原型验证的思考</title><updated>2026-01-19T07:31:35.086466+00:00</updated><content type="html"><![CDATA[<h1>摘要</h1>
<p>在芯片项目的验证阶段中，主要分为硅前以及硅后两个大的阶段，在不同的阶段，各个团队的验证侧重点略有不同，但是同样的需要保证验证的质量，而验证的质量从验证的完备性去衡量；</p>
<p>而实际操作过程中，会根据芯片自研程度、模块规模、商用化目的、人力投入、职责划分等情况，验证策略会跟随着做出一些适时的调整，最终以在现有条件下达成芯片验证的目的；</p>
<p>在目前大部分芯片项目中，真正核心自研的东西其实并不太多，大部分情况下，更多的是三方集成+自研的模式，所以根据这种情况，项目应该以什么样的策略去应对，这个也是本文想要总结思考的；</p>
<!-- more -->
<h1>验证流程</h1>
<p>在一般的芯片公司，负责芯片验证的主要有几个相关的团队：</p>
<p>[<em>前端设计</em>] ---&gt; 前端验证 ---&gt; [<em>原型验证</em>] ---&gt; 底软解决方案</p>
<p><strong>前端设计</strong>会部分参与到前端验证的质量活动中，比如类似于代码review，覆盖率分析，波形检视等；</p>
<p><strong>前端验证</strong>在硅前阶段的时候，是芯片signoff的主要责任团队，从意义上来说，硅前阶段，只有前端验证可以从RTL代码层面上，进行白盒验证，保证验证的完备性；在硅后阶段，前端验证基本不参与验证；</p>
<p><strong>原型验证</strong>在有些公司不一定存在，原型验证主要的工作在硅前是在FPGA以及Emulation平台上面进行软硬件的原型验证，更加偏向于系统级别的场景验证、压力验证、性能验证以及各个模块配合的集成验证；硅后阶段，针对工程样片负责功能、压力、性能等验证，针对下游做功能的出口；因此这部分工作在有些公司或者小芯片项目中，被底软团队以及前端验证团队覆盖；</p>
<p><strong>底软解决方案</strong>在芯片开发验证过程中，主要是针对交付的SDK进行开发，在对SDK进行软件验证的同时，也能兼顾部分芯片功能的验证，但是更多偏向软件功能的交付，并且主要参与硅后阶段，硅前大部分情况下，只是进行软硬件方案的开发；</p>
<p>在海思、平头哥、Intel等大型芯片公司，都有类似的原型验证团队，可能在工作细节上面有些出入，但是大体上都差不多；</p>
<p><strong>芯片开发验证的大致流程</strong>以及阶段如下：</p>
<p><img src="https://github.com/user-attachments/assets/2b8d8217-f0b1-48aa-a2da-7d88ba7ea05c" alt="芯片开发验证流程" /></p>
<p><strong>TR1/TR2 阶段</strong>：这个阶段基本上原型验证不会参与，属于立项以及需求收集分析、架构设计阶段，</p>
<p><strong>TR3 阶段</strong>：这个阶段前端验证/原型验证开始大量投入：</p>
<ul>
<li>85%阶段：前端验证团队开始根据交付特性进行验证，原型团队开始做验证前的质量活动，验证方案开发、驱动代码开发，用例开发，模块冒烟等等；</li>
<li>100%阶段：前端验证基本大部分功能已经完成验证，原型团队也可以针对全量用例进行第一次整体测试，压力、性能等验证也相应启动；</li>
<li>Freezon阶段：RTL代码冻结，前端验证开始做覆盖率等质量活动，原型团队重点投入在性能Validation、压力验证等活动，部分质量活动也相应开启；</li>
<li>ECO阶段：前端验证质量活动基本完成，开始进行更细致的corner验证或者联合原型进行前后端验证增补、网表仿真启动等；原型启动TO前的用例全量回归，大部份质量活动完成</li>
<li>TO/TR4阶段：前端验证任务基本完成，原型验证开始准备CB点亮以及样片验证相关工作；</li>
</ul>
<p><strong>CB阶段（chip back）</strong>: 这个阶段芯片点亮以及验证的主力是原型验证团队以及底软解决方案团队，前者需要完成样片的点亮以及全量用例的测试，长时间大压力的测试也需要在这个阶段完成；芯片相关的性能数据的validation也需要完成输出以及优化；原型团队同时需要联合硬件团队完成电气特性测试以及SLT软件开发；底软团队开始针对样片的产品环境进行底软的调试，以及完成底软SDK的开发发布测试等流程活动，</p>
<p><strong>TR5阶段</strong>：标识芯片正式可以量产，相应测试以及质量、成本等达到设计预期，开始正式上市；</p>
<p>如上可知，原型团队主要在<strong>硅前做好前端验证的质量守门员</strong>，<strong>硅后芯片质量的交付团队</strong>；</p>
<h1>项目验证策略</h1>
<p>在实际项目的过程中，芯片开发大部分的情况下，芯片内部模块可能分成几类：</p>
<ul>
<li>A.完全自研的模块，并且首次使用</li>
<li>B.完全自研的模块，但是已经在多颗量产芯片上应用，修改量较小</li>
<li>C.第三方采购模块，但是首次应用项目</li>
<li>D.第三方采购模块，模块规模<strong>较小</strong>，并且已经多个量产芯片应用，修改量较小或无修改</li>
<li>E.第三方采购模块，设计规模<strong>较大</strong>，并且已经多个量产芯片应用，修改量较小或无修改</li>
</ul>
<p>按照验证的功能细致程度或者验证需求来分类，也可以根据上述模块，分成以下几类：</p>
<ul>
<li>全量验证，做好完备的测试点，甚至在原型阶段尽量做到白盒化验证；（比如上述A类型模块）</li>
<li>增量验证，做好集成验证，主要包含性能、压力、增量特性以及自动化测试套；（比如上述B/C/E类型模块）</li>
<li>以用代验，通过验证系统，其它模块配合验证，以用代验的方式，完成验证；(比如上述D类型模块)</li>
</ul>
<p>在原型验证的不同阶段，职责也会有相应的区分，因此在侧重点上也有一定的倾向，这里会对原型验证的自动化程度有比较高的要求，只有在高度自动化的情况下，可以实现以最小的人力，最快的速度完成对于相应验证工作的快速闭环以及人力的节省；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/25"/><category term="总结思考"/><published>2024-08-05T07:47:01+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/24</id><title>python In 机器学习(一)</title><updated>2026-01-19T07:31:35.526423+00:00</updated><content type="html"><![CDATA[<h1>LinearRegression</h1>
<p>这里简单记录一下最近学习的算法代码</p>
<!-- more -->
<h2>多元线性回归算法</h2>
<p>这里主要通过sklearn获取数据进行实验</p>
<pre><code class="language-python">from sklearn import *
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import torch

if __name__ == &#x27;__main__&#x27;:
    # 加载糖尿病数据集
    data = datasets.load_diabetes()
    data_X = data.data
    data_Y = data.target
    # 拆分训练集以及预测数据
    X_train, X_test, Y_train, Y_test = train_test_split(data_X, data_Y, test_size=0.2)

    # 创建一个多元线性回归算法对象
    lr = LinearRegression()

    # 使用训练集训练模型
    lr.fit(X_train, Y_train)

    # 使用测试集进行预测
    Y_pred = lr.predict(X_test)
    Y_pred_train = lr.predict(X_train)
    # 打印模型的均方差
    print(f&quot;pred loss : {mean_squared_error(Y_test, Y_pred)}&quot;)

    print(f&quot;Y_pred_train loss : {mean_squared_error(Y_train, Y_pred_train)}&quot;)
    pass

</code></pre>
<h2>分类</h2>
<p>这里是分类的应用：</p>
<ul>
<li>logistics回归 ： OVR，one vs other，将多分类当成多个二分类</li>
<li>softmax：一次得到多个分类的概率</li>
</ul>
<pre><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

if __name__ == &#x27;__main__&#x27;:
    # 加载数据
    iris = datasets.load_iris()

    X = iris.data
    Y = iris.target

    print(f&quot;Y = {Y}&quot;)

    # 切分数据
    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)

    # 创建模型, 根据数据决定是用二分类还是多分类
    # 使用logistics回归还是softmax回归 ，取决于multiclass参数
    # ovr ： 1对其它
    # multinomial ： softmax
    #  &quot;multi_class&quot;: [
    #             StrOptions({&quot;auto&quot;, &quot;ovr&quot;, &quot;multinomial&quot;}),
    #             Hidden(StrOptions({&quot;deprecated&quot;})),
    #         ],
    lr = LogisticRegression(max_iter=1000000)

    # 使用训练集训练模型
    lr.fit(X_train, y_train)

    # 对测试集进行预测
    y_pred = lr.predict(X_test)

    # 打印模型的准确率
    print(f&quot;accuracy = {accuracy_score(y_test, y_pred)}&quot;)

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/24"/><category term="python 机器学习"/><published>2024-08-03T08:25:19+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/16</id><title>聊一聊职业机会</title><updated>2026-01-19T07:31:35.654029+00:00</updated><content type="html"><![CDATA[<p>挺有意思的一件事，最近公司在做组织结构调整，有基层领导岗位的竞聘机会，于是给到自己团队内的核心骨干提示，希望相关骨干能够有勇气，有能力去竞聘一下，本以为会有比较多的同学尝试一下，但是实际的结果却出乎我的意料，最终竞聘的时候，没有一个同学敢于尝试；这里就引申了一个话题，作为研发人员，在职场的机会是什么？</p>
<!-- more -->
<h1>回顾</h1>
<p>我在研发行业也算从业了10多年了，从一个基层研发到10来人的小团队leader到现在leader了几十上百人，其实看到过很多人包括自己在工作中经常会有的思考：</p>
<ul>
<li>我现在做的这个事情的意义是什么</li>
<li>我在这里做几年后，我未来应该要怎么走</li>
<li>是不是要换个方向</li>
<li>要不要跳槽，换个公司</li>
</ul>
<p>这里我们先把这些问题放置一边，简单回顾一下自己这些年职场发展过程；</p>
<hr />
<p>在自己的职业发展过程中，一方面确实吃到了时代的红利，给了自己在工作、待遇上非常大的帮助；另外一方面，个人在其中也是花了很大的精力；
总结这十多年的过程来看，我认为主要有几个点起到了关键性的作用：</p>
<ul>
<li>韧性</li>
<li>学习能力</li>
<li>做事的方式方法</li>
</ul>
<h2>韧性</h2>
<p>为什么把<strong>韧性</strong>排在了第一位？
这不得不回想起整个职业生涯里面的几个关键节点：
<strong>第一个节点</strong>是初入职场时候身份的转变，我们从象牙塔里面出来，之前最大的压力，无非是作业、考试，影响的仅仅是自己一个人，但是项目职场中，个人的事务往往牵扯上下游相关的同事，一个人进度的影响可能导致的是整个周边的delay，这里带来的情绪上，压力上的强度是相比之前不可同日而语的；</p>
<p>回想同一批进入华为的同学，大概一个大班级有150人左右，一年后，剩余的不过80人，基本已经淘汰一半 ，而这一半很多同学是无法适应在激烈对抗的公司里面的压力而离开的；</p>
<p><strong>第二个节点</strong>，是工作三年后，这个时候，容易产生职场的疲惫，特别是在华为这样的公司里面，竞争激烈，工作强度大，很容易造成放弃；</p>
<p>还记得15年的时候，当时在实验室里面连续工作了3~4个月，巨大的工作强度以及工作压力，差一点就提了离职，5.1号劳动节当天回了老家买房，本来打算回来就提离职的，不过因为最后想着再咬咬牙坚持一下，最终还是扛过了这段黑暗的时光，也熬出了一个很好的上升机会；</p>
<p><strong>第三个节点</strong>，是自己升任团队基层管理者的时候，带了10个人负责一个方向的事务，工作开始变得杂乱，不像以前那么单纯，这个时候，由于有了一定的能力，周边的干扰开始多了起来，各种相关的职场机会也找来了，但是是不是找来的一定是个好机会，不一定见得，但是知道得是，那个阶段走出去得同学，目前看，还没有在职场混的更好得同学；</p>
<p>以上想说明得是什么？很多时候，我们认为一些事情很难扛过去，但是咬咬牙，等这件事情真的过去了之后，再看看，其实好像也没有什么，反而在这个过程中，我们得能力、影响力都得到了提升；</p>
<p>所以，人一定要有<strong>韧性，耐操，不玻璃心</strong>，这个是我认为在职场中，最为核心的内在能力之一</p>
<h2>学习能力</h2>
<p>个人认为第二重要的就是学习能力！</p>
<p>在笔者经历的这些大厂的工作生涯里面，对于一个新的领域，是否能够很快的上手，很快的掌握核心能力，是决定一个人能否拿出结果的重要能力；</p>
<p>在学校阶段，笔者是学习J2EE的，即java/struct/hibernate/spring这一套，但是入职后，就被分配到了芯片行业，当时我连arm芯片是什么都不知道，刚入职领导让用C写一个简单的memory copy也整不明白，更不用说，对于底层软件的执行逻辑、操作系统的理解了，毕竟大学都是60分万岁通过的；</p>
<p>但是入职半年左右，通过没日没夜的学习，笔者很快在同年入职的新员工里面脱颖而出，特别的是大部分还是研究生，拿到了当年的最佳新员工；</p>
<p>这里面，当然也有一些技巧，简单来说，笔者学习总是伴随着问题学习，以解决问题为目的的学习，同时伴随着模仿以及厚脸皮的请教，能够很快的上手项目工作并且顺利的交付；</p>
<p>当然，这样的学习方式也是有一定的代价，掌握的深度有点不够的，但是能够快速的掌握大量的知识，在广度上，帮助非常大；至于深度，则需要跟随自己手上的工作花更多的精力去掌握~</p>
<h2>做事的方式方法</h2>
<p><strong>酒香还怕巷子深</strong></p>
<p><strong>低调做人，高调做事！</strong></p>
<p>笔者做事的方式一向比较高调，不管是及时的跟自己的领导同步进展，还是积极主动的去寻求问题的解决办法，总之，一切以把事情完成为目的的去做事，这个过程可能很多人会觉得很高调，类似于献殷勤！</p>
<p>但是需要明白的是，这个跟献殷勤是有很大的区别的，这里的区别在于献殷勤更多的是打感情牌，而主动的沟通交流，主动的汇报进展，更多的是像领导展现自己的能力，中国人向来含蓄，但是笔者认为在职场中，能多外向就多外向，外向型性格，在职场中，总是会吃得香~</p>
<hr />
<p>说了这么多，其实笔者最后想总结的一点是：</p>
<p>机会，是留给有准备的人，是留给主动争取的人，是留给有韧性、学习能力、懂做事方法的人，当机会出现的时候，就要积极的去尝试，争取，哪怕是去露个脸，也总比白白放过要强~</p>
<p>这里也是提醒自己，<strong>生活中，有些机会稍纵即逝，把握与放弃，就在一念之间！</strong></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/16"/><category term="生活感悟"/><published>2024-06-04T05:54:14+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/15</id><title>Qemu Virt平台集成ARM PL080 DMA</title><updated>2026-01-19T07:31:35.784260+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<p>最近有比较多的新员工入职，新员工入职如何更快的适应工作，需要通过一些虚拟项目进行工作培训；但是如果利用现有的芯片平台进行验证，有几个缺陷：</p>
<ul>
<li>当前芯片略显复杂，新员工接手理解难度较高</li>
<li>平台已经solid，并且有参考的代码以及测试用例，对于新员工而言，没有起到端到端cover一个模块的作用</li>
<li>难以预埋bug，无法通过挖掘设计bug，衡量验证效果</li>
</ul>
<p>因此根据实际工作需求，设计了一个可以给到新员工练兵的验证项目，利用qemu平台，集成一个简单的DMA模块，并且在模块中预埋一些bug，让新员工提前感知在后续验证过程中，应该要重点关注的一些验证重点，验证难点，同时也可以观察在整个新员工项目过程中，新员工的表现，识别高潜人才；</p>
<!-- more -->
<h1>验证平台开发</h1>
<h2>集成开发环境</h2>
<p>Qemu针对arm类的处理器，提供了一个单纯的开发环境，Virt平台，如下是virt平台的一些简述：</p>
<blockquote>
<p><a href="https://www.qemu.org/docs/master/system/riscv/virt.html#virt-generic-virtual-platform-virt">‘virt’ Generic Virtual Platform</a>
The virt board is a platform which does not correspond to any real hardware; it is designed for use in virtual machines. It is the recommended board type if you simply want to run a guest such as Linux and do not care about reproducing the idiosyncrasies and limitations of a particular bit of real-world hardware.
<a href="https://www.qemu.org/docs/master/system/riscv/virt.html#supported-devices">Supported devices</a>
The virt machine supports the following devices:</p>
<ul>
<li>Up to 512 generic RV32GC/RV64GC cores, with optional extensions</li>
<li>Core Local Interruptor (CLINT)</li>
<li>Platform-Level Interrupt Controller (PLIC)
*CFI parallel NOR flash memory</li>
<li>1 NS16550 compatible UART</li>
<li>1 Google Goldfish RTC</li>
<li>1 SiFive Test device</li>
<li>8 virtio-mmio transport devices</li>
<li>1 generic PCIe host bridge</li>
<li>The fw_cfg device that allows a guest to obtain data from QEMU
The hypervisor extension has been enabled for the default CPU, so virtual machines with hypervisor extension can simply be used without explicitly declaring.</li>
</ul>
</blockquote>
<p>所以在Virt平台中，简单集成一下virtio-mmio设备即可；</p>
<p>于此同时，对于验证新手项目而言，DMA设备是一个能够比较小巧又比较全面的设备，因此可以选择一个相对简单的DMA集成到环境中即可；</p>
<h2>DMA选型</h2>
<p>在原生qemu 代码中，提供了如下几款DMA设备：</p>
<ul>
<li>bcm2835_dma</li>
<li>omap_dma</li>
<li>arm pl080 dma</li>
<li>arm pl330 dma</li>
<li>xlnx的3款dma</li>
<li>...
<img src="https://github.com/Jared-ZDC/markel/assets/17999499/8631ad56-50c5-4a4d-b657-699aaee31024" alt="qemu dma" /></li>
</ul>
<p>从选择的几个dma spec内容看起来，arm的pl080 dma相对简单，并且有完善的spec资料以及开源支持的驱动代码，因此在选型上个人更偏向arm PL080 DMA设备；</p>
<h2>集成DMA</h2>
<p>qemu virt集成的方式比较简单，首先看一下pl080的设备描述：</p>
<pre><code class="language-c">static Property pl080_properties[] = {
    DEFINE_PROP_LINK(&quot;downstream&quot;, PL080State, downstream,
                     TYPE_MEMORY_REGION, MemoryRegion *),
    DEFINE_PROP_END_OF_LIST(),
};
</code></pre>
<p>PL080的属性只有一个downstream， 类型是memory region类型，表示dma 链接系统memory的区域， 因此在qemu virt平台中集成只要对downstream进行处理即可：</p>
<pre><code class="language-c">//virt.c
static const MemMapEntry base_memmap[] = {
    /* Space up to 0x8000000 is reserved for a boot ROM */
    [VIRT_FLASH] =              {          0, 0x08000000 },
...
    [VIRT_DMA] =                { 0x09011000, 0x00001000 },
...
    [VIRT_MEM] =                { GiB, LEGACY_RAMLIMIT_BYTES },
};

static const int a15irqmap[] = {
    [VIRT_UART] = 1,
    [VIRT_RTC] = 2,
...
    [VIRT_PLATFORM_BUS] = 112, /* ...to 112 + PLATFORM_BUS_NUM_IRQS -1 */
    [VIRT_DMA] = 212,
};
static void create_dma(const VirtMachineState *vms)
{
    int i;
    char *nodename;
    hwaddr base = vms-&gt;memmap[VIRT_PDMA].base;
    hwaddr size = vms-&gt;memmap[VIRT_PDMA].size;
    int irq = vms-&gt;irqmap[VIRT_PDMA];
    const char compat[] = &quot;arm,pl080\0arm,primecell&quot;;
    const char irq_names[] = &quot;intr\0interr\0inttc&quot;;
    DeviceState *dev;
    MachineState *ms = MACHINE(vms);
    SysBusDevice *busdev;

    dev = qdev_new(&quot;pl080&quot;);

    object_property_set_link(OBJECT(dev), &quot;downstream&quot;, OBJECT(get_system_memory()), &amp;error_fatal);

    busdev = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(busdev, &amp;error_fatal);
    sysbus_mmio_map(busdev, 0, base);

    for (i = 0; i &lt; 3; ++i) {
        sysbus_connect_irq(busdev, i, qdev_get_gpio_in(vms-&gt;gic, irq + i));
    }

    nodename = g_strdup_printf(&quot;/pl080@%&quot; PRIx64, base);
    qemu_fdt_add_subnode(ms-&gt;fdt, nodename);
    qemu_fdt_setprop(ms-&gt;fdt, nodename, &quot;compatible&quot;, compat, sizeof(compat));
    qemu_fdt_setprop_sized_cells(ms-&gt;fdt, nodename, &quot;reg&quot;,
                                 2, base, 2, size);
    qemu_fdt_setprop_cells(ms-&gt;fdt, nodename, &quot;interrupts&quot;,
                    GIC_FDT_IRQ_TYPE_SPI, irq, GIC_FDT_IRQ_FLAGS_LEVEL_HI,
                    GIC_FDT_IRQ_TYPE_SPI, irq + 1, GIC_FDT_IRQ_FLAGS_LEVEL_HI,
                    GIC_FDT_IRQ_TYPE_SPI, irq + 2, GIC_FDT_IRQ_FLAGS_LEVEL_HI);

    qemu_fdt_setprop(ms-&gt;fdt, nodename, &quot;interrupt-names&quot;, irq_names,
                     sizeof(irq_names));

    qemu_fdt_setprop_cell(ms-&gt;fdt, nodename, &quot;clocks&quot;, vms-&gt;clock_phandle);
    qemu_fdt_setprop_string(ms-&gt;fdt, nodename, &quot;clock-names&quot;, &quot;apb_pclk&quot;);

    g_free(nodename);
}

</code></pre>
<p>为了验证集成dma的寄存器访问正确性， 单独将0x64寄存器设置为魔术字寄存器，可读，可写</p>
<pre><code class="language-patch">//dma集成读写测试用
diff --git a/qemu/qemu-8.1.4/hw/dma/pl080.c b/qemu/qemu-8.1.4/hw/dma/pl080.c
index a03dcf428..9ff191a02 100644
--- a/qemu/qemu-8.1.4/hw/dma/pl080.c
+++ b/qemu/qemu-8.1.4/hw/dma/pl080.c
@@ -221,6 +221,8 @@ static uint64_t pl080_read(void *opaque, hwaddr offset,
     uint32_t i;
     uint32_t mask;

+    qemu_log_mask(LOG_GUEST_ERROR,&quot;pl080_read %x, %d,  size %x\n&quot;, offset, offset &gt;&gt; 2, size);
+
     if (offset &gt;= 0xfe0 &amp;&amp; offset &lt; 0x1000) {
         if (s-&gt;nchannels == 8) {
             return pl080_id[(offset - 0xfe0) &gt;&gt; 2];
@@ -275,6 +277,8 @@ static uint64_t pl080_read(void *opaque, hwaddr offset,
         return s-&gt;conf;
     case 13: /* Sync */
         return s-&gt;sync;
+    case 16: /*magic word*/
+       return s-&gt;magic_words;
     default:
     bad_offset:
         qemu_log_mask(LOG_GUEST_ERROR,
@@ -289,6 +293,7 @@ static void pl080_write(void *opaque, hwaddr offset,
     PL080State *s = (PL080State *)opaque;
     int i;

+    qemu_log_mask(LOG_GUEST_ERROR,&quot;pl080_write %x, size %x, value %x\n&quot;, offset, size, value);
     if (offset &gt;= 0x100 &amp;&amp; offset &lt; 0x200) {
         i = (offset &amp; 0xe0) &gt;&gt; 5;
         if (i &gt;= s-&gt;nchannels)
@@ -338,6 +343,8 @@ static void pl080_write(void *opaque, hwaddr offset,
     case 13: /* Sync */
         s-&gt;sync = value;
         break;
+    case 16: /*magic word*/
+       s-&gt;magic_words = value;
     default:
     bad_offset:
         qemu_log_mask(LOG_GUEST_ERROR,
@@ -366,7 +373,7 @@ static void pl080_reset(DeviceState *dev)
     s-&gt;req_single = 0;
     s-&gt;req_burst = 0;
     s-&gt;running = 0;
-
+    s-&gt;magic_words = 0x55aa55aa;
     for (i = 0; i &lt; s-&gt;nchannels; i++) {
         s-&gt;chan[i].src = 0;
         s-&gt;chan[i].dest = 0;
</code></pre>
<h2>编译</h2>
<p>将qemu编译完成后，使用如下命令启动系统：</p>
<pre><code class="language-bash">build/qemu-system-aarch64 \
    -nographic \
    -M virt,virtualization=true,gic-version=3 \
    -cpu cortex-a76 \
    -smp 4 \
    -m 8G \
    -kernel ../../linux/linux-6.6/arch/arm64/boot/Image \
    -append &quot;rootfstype=ramfs rdinit=/linuxrc console=ttyAMA0&quot; \
    -initrd ../../busybox/busybox-1.36.1/initrd.cpio.gz
</code></pre>
<h2>测试</h2>
<h3>dump dma寄存器</h3>
<p>通过dump dma的寄存器，简单看一下dma寄存器是否按照预期集成完成</p>
<pre><code class="language-bash">[root:DMA: ~]# devmem 0x9012040
0x55AA55AA
[root:DMA: ~]# devmem 0x9012040 32 0xaa55aa55
[root:DMA: ~]# devmem 0x9012040
0xAA55AA55
</code></pre>
<p>寄存器读写功能正常</p>
<h3>dma搬运测试</h3>
<h4>dma测试驱动</h4>
<p>简单写一个dma测试代码，搬运两个地址的数据，并进行搬运后数据检查，看看中断是否正常上报</p>
<pre><code class="language-c">static ssize_t memcpy_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {
    // 实现 memcpy 文件的写操作
    // 检查输入参数
    if (count &gt; BUFFER_SIZE) {
        return -EINVAL;
    }

    // 从用户空间拷贝数据到 buffer_in
    if (copy_from_user(buffer_in, buf, count)) {
        return -EFAULT;
    }

    // 设置 DMA 传输参数
    struct dma_async_tx_descriptor *desc;
    dma_addr_t src_addr = virt_to_phys(buffer_in);
    dma_addr_t dst_addr = virt_to_phys(buffer_out);

    memset(buffer_in,0x5a,0x40);
    memset(buffer_out,0x0,0x40);
    pr_info(&quot;dump buffer_in\n&quot;);
    dump(buffer_in, 0x40);


    desc = dmaengine_prep_dma_memcpy(dma_chan, dst_addr, src_addr, 0x40, DMA_MEM_TO_MEM);
    if (!desc) {
        pr_err(&quot;Failed to prepare DMA transfer\n&quot;);
        return -EBUSY;
    }

    desc-&gt;flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
    // 设置 DMA 完成中断处理函数
    desc-&gt;callback = dma_complete_callback;
    desc-&gt;callback_param = NULL;

    pr_err(&quot;prepare to sumbit\n&quot;);

    // 启动 DMA 传输
    dmaengine_submit(desc);
    pr_err(&quot;prepare to async\n&quot;);
    dma_async_issue_pending(dma_chan);

    msleep(2000);

    pr_info(&quot;dump buffer_out\n&quot;);
    dump(buffer_out, 0x40);

    // 等待 DMA 传输完成
    /*
    while (!dma_complete) {
        cpu_relax();
    }
*/
 //   dma_complete = false;
    return count;
}

static int dmatest_device_init(void)
{
    // 1. 创建设备类
    dmatest_device_class = class_create(&quot;dmatest_device_class&quot;);
    if (IS_ERR(dmatest_device_class)) {
        printk(KERN_ERR &quot;Failed to create device class\n&quot;);
        return PTR_ERR(dmatest_device_class);
    }

    // 2. 创建设备
    dmatest_device = device_create(dmatest_device_class, NULL, MKDEV(230, 0), NULL, &quot;dmatest&quot;);
    if (IS_ERR(dmatest_device)) {
        printk(KERN_ERR &quot;Failed to create device\n&quot;);
        class_destroy(dmatest_device_class);
        return PTR_ERR(dmatest_device);
    }

    printk(KERN_INFO &quot;dmatest_device created successfully\n&quot;);
    return 0;
}


static int dmatest_init(void) {



    if(dmatest_device_init())
        return -1;

    dmatest_dir = proc_mkdir(&quot;dmatest&quot;, NULL);
    if (!dmatest_dir) {
        pr_err(&quot;Failed to create dmatest directory in procfs\n&quot;);
        return -ENOMEM;
    }

    memcpy_file = proc_create(&quot;memcpy&quot;, 0644, dmatest_dir, &amp;memcpy_fops);
    if (!memcpy_file) {
        pr_err(&quot;Failed to create memcpy file in procfs\n&quot;);
        remove_proc_entry(&quot;dmatest&quot;, NULL);
        return -ENOMEM;
    }

    status_file = proc_create(&quot;status&quot;, 0444, dmatest_dir, &amp;status_fops);
    if (!status_file) {
        pr_err(&quot;Failed to create status file in procfs\n&quot;);
        remove_proc_entry(&quot;memcpy&quot;, dmatest_dir);
        remove_proc_entry(&quot;dmatest&quot;, NULL);
        return -ENOMEM;
    }

    pr_info(&quot;dmatest directory and files created in procfs\n&quot;);
    return 0;
}

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/15"/><category term="程序人生"/><published>2024-06-04T05:34:28+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/14</id><title>交叉编译Openblas库</title><updated>2026-01-19T07:31:35.934565+00:00</updated><content type="html"><![CDATA[<h1>下载源码</h1>
<pre><code class="language-bash">git clone https://github.com/OpenMathLib/OpenBLAS.git
</code></pre>
<h1>编译</h1>
<pre><code class="language-bash">gmake TARGET=ARMV8 BINARY=64 HOSTCC=gcc CC=aarch64-linux-gnu-gcc FC=aarch64-linux-gnu-gfortran

#可以查看Targetlist.txt看支持哪些目标平台
</code></pre>
<!-- more -->
<h2>注意</h2>
<p><img src="https://github.com/Jared-ZDC/markel/assets/17999499/bca51fc3-2640-463d-8cf8-2d5387540244" alt="image" />
出现这种错误，是因为可能存在windows跟unix的脚本转换错误，这里使用dos2unix将系统目录整体处理一边</p>
<pre><code class="language-bash">dos2unix ./*
dos2unix exports/gensymbol
</code></pre>
<h1>编译完成</h1>
<pre><code class="language-bash"> OpenBLAS build complete. (BLAS CBLAS LAPACK LAPACKE)

  OS               ... Linux
  Architecture     ... arm64
  BINARY           ... 64bit
  C compiler       ... GCC  (cmd &amp; version : aarch64-linux-gnu-gcc (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0)
  Fortran compiler ... GFORTRAN  (cmd &amp; version : GNU Fortran (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0)
  Library Name     ... libopenblas_armv8p-r0.3.27.dev.a (Multi-threading; Max num-threads is 20)

To install the library, you can run &quot;make PREFIX=/path/to/your/installation install&quot;.
</code></pre>
<h1>编译benchmark</h1>
<pre><code class="language-bash">cd benchmark
gmake TARGET=ARMV8 BINARY=64 HOSTCC=gcc CC=aarch64-linux-gnu-gcc FC=aarch64-linux-gnu-gfortran
</code></pre>
<h1>测试</h1>
<pre><code class="language-bash">
#设置循环次数
export OPENBLAS_LOOPS=10000000
export OPENBLAS_PARAM_M=200
export OPENBLAS_PARAM_N=200
export OPENBLAS_PARAM_K=200

#设置线程数量，对于某些测试，不一定生效
export OPENBLAS_NUM_THREADS=4

#测试
./sgemm.goto 

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/14"/><category term="程序人生"/><published>2024-06-03T08:06:28+00:00</published></entry></feed>