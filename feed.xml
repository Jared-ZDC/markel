<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/Jared-ZDC/markel</id><title>RSS feed of Jared-ZDC's markel</title><updated>2024-08-20T13:24:44.915438+00:00</updated><link href="https://github.com/Jared-ZDC/markel"/><link href="https://raw.githubusercontent.com/Jared-ZDC/markel/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/Jared-ZDC/markel/issues/30</id><title>周总结及计划（20240819-20240825）</title><updated>2024-08-20T13:24:45.170623+00:00</updated><content type="html"><![CDATA[<h1>Summary and Plan</h1>
<p>总体来说，上周发生了比较多的事情，感觉到心累！！可是，日子还要过下去；
很多时候，工作事情容易处理，生活的事情却难以抉择，无论是面对即将汰换的老员工，还是斩断三千烦恼丝，都是一件让人前后纠结的事情；
清官难断家务事，或许便是如此；</p>
<p>上周解决了一个裁员的大难题，团队整体看，没有我想象的那么悲观，真的在沟通的那一刻，又好像水到渠成，一切似乎都那么平静，这个倒是了却了我的一大心结；</p>
<!-- more -->
<p>项目上，上周还有较多的事情没有完成，这个怪我，没有支棱起来，上周萎靡了一周，没有太过于关注项目的进展，导致整体的进展实际上跟预期相差较大，本周这里需要更激进一点，跟的不紧，很多事情就会跟丢了；</p>
<p>分开几个事情看一下，整体目标没有达成预期，相差的还有不少距离：</p>
<p><strong>理财项目</strong></p>
<ul>
<li>完成量化交易mongodb的存储编码  --- 看起来还是没有完成，基本没有任何投入，主要是周末两天有生活上的安排，导致没有投入，这个本周还是要花一些时间在里面的，完成存储部分，不能一直拖着</li>
</ul>
<p><strong>阅读</strong></p>
<ul>
<li>华为的绩效管理书是看完了，但是留的印象不多，需要做一下总结，这个本周完成</li>
<li>心理学相关的书籍，还是要看一下，本周《大众心理学》 看个一半吧</li>
</ul>
<p><strong>工作</strong></p>
<ul>
<li>绩效沟通完成几个TL以及关键人物的沟通 --- 本周持续进行，完成整个绩效的沟通，同时辅助新进小组长完成他们团队的一次沟通；</li>
<li>整体的验证策略好好梳理一下，解决掉尾巴问题 --- 这个本周要内部评审一下几个项目的策略，包括自己也要好好梳理一下，还是有点混乱</li>
<li>项目上进行一下收尾，几个要交付的资料本周让大家动起来</li>
<li>长稳相关的工作也要开展起来
<em><strong>o(╥﹏╥)o，感觉上周什么事情也没有做一样，白混过去了，得检讨一下自己</strong></em></li>
</ul>
<p><strong>AI算法</strong></p>
<ul>
<li>上周没有投入，这周末有一些安排，估计很难投入，先pending</li>
</ul>
<p><strong>运动锻炼</strong></p>
<ul>
<li>本周完成20公里的运动跑步 --- 上周完全荒废，这周早起跑吧，试试早上跑完一整天累不累</li>
<li>控制一下饮食，保持大概4天的晚上不吃宵夜  --- 嗯，继续保持</li>
<li>力量训练保持4天完成吧  --- 上周完成了1/4，成绩有点差，本周估计要继续</li>
<li>体侧结果有点差呀， 32.8%的体脂，比原先估计的还要多，坚持一个月晚上不吃碳水；
<img src="https://github.com/user-attachments/assets/a9b7eda8-0658-476f-9832-ae213e4b6af7" alt="20240819体测结果" /></li>
</ul>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/30"/><category term="周计划总结"/><published>2024-08-19T03:28:08+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/29</id><title>生活的懈怠之本周计划(20240812)</title><updated>2024-08-20T13:24:45.282081+00:00</updated><content type="html"><![CDATA[<p>最近这一个月，工作以及生活上有些懈怠~~~
不想工作<del>
不想学习</del>
不想理财<del>
也不想游戏</del>
就是看看小说，刷刷抖音，似乎也过去了，还有偷偷打个麻将~</p>
<!-- more -->
<hr />
<p>这一周周一，一天开了几个会，突然间发现已经有些跟不上了，好几个问题的定位分析，已经有点深入不进去，开始慢慢掉队了；
感觉这是一个危险信号，是不是在这个位置上就开始躺平了，明明自己知道，在好几个地方，都还没有实际上做出成绩，收入也才刚刚完成负债收敛，这个时候，才正式开始积攒家底的时候，不应该这个时候就开始松懈；</p>
<p>想想还是给自己立一些flag，先不说远的，从周计划开始吧，做做周计划，搞搞周总结，人嘛，还是要有一些约束以及奔头的，给自己找点事情做吧；</p>
<p><strong>理财</strong></p>
<ul>
<li>本周完成量化交易mongodb的存储编码，至少可以将远端数据存储起来，先不讲究通用性，先把可用解决吧，后续有时间再解决扩展问题，估计也就自己用，无所谓了；</li>
</ul>
<p><strong>阅读</strong></p>
<ul>
<li>看完一本绩效相关的书籍吧，整理一篇相关的读书笔记吧</li>
</ul>
<p><strong>工作</strong></p>
<ul>
<li>绩效沟通完成几个TL以及关键人物的沟通</li>
<li>整体的验证策略好好梳理一下，解决掉尾巴问题</li>
<li>项目上进行一下收尾，几个要交付的资料本周让大家动起来</li>
<li>长稳相关的工作也要开展起来</li>
</ul>
<p><strong>AI算法</strong></p>
<ul>
<li>再推进5节课程吧，整体上输出两三篇学习笔记吧</li>
</ul>
<p><strong>运动锻炼</strong></p>
<ul>
<li>本周完成20公里的运动跑步</li>
<li>控制一下饮食，保持大概4天的晚上不吃宵夜</li>
<li>力量训练保持4天完成吧</li>
</ul>
<p>等到周五看看本周的总结的完成情况，再去制定下周的计划~~~</p>
<p>还是要往前push自己一下，现在还不到躺平的时候，或许明年可以吧，慢慢来~~</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/29"/><category term="周计划总结"/><published>2024-08-12T11:48:23+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/28</id><title>高级别同学的汰换沟通策略梳理</title><updated>2024-08-20T13:24:45.411548+00:00</updated><content type="html"><![CDATA[<p>最近团队内给了一个高级别，并且是业务团队的小主管打了一个M-的绩效，按照公司要求，打了M- 的同学会被公司辞退；那么怎么样跟这个同学沟通，能够尽可能减小的对整个部门的影响，这是我这两周以来一直在思考的问题~</p>
<!-- more -->
<p>坦白说，当时整个部门分成了5个小的业务团队，在我空降这个部门任职部长的时候，这个同学是最为配合工作的一个主管，我花费的沟通成本是最低的；</p>
<p>但是从实际的这两年的共同工作来看，这个同学有一个比较明显的问题，可能也是工作那么多年以来的习惯，很多事情吩咐下去，虽然口头上不会反驳一点，但是实际在完成这件事情的时候，会有一大堆的问题以及理由告诉你，这件事做不到；这个在我的职业生涯里面，其实是很难以接受的，因为对于高级别的同学，其实要求的是问题的解决能力以及规划能力，并不是执行能力；对于部门的业务方向上的事情，需要有自己的解决策略，而并不是每次面对事情的时候，先给我抛出一大堆的困难，然后告诉我，这件事情很难做；</p>
<p><strong>我们评价一件事情要不要做，不是看这件事情难不难做，而是看这件事做了有没有必要，如果有必要，能够带来收益，就是再难，也要做成，如果没有必要，再简单也不用做！</strong></p>
<p>当然了，现在的问题已经不是评价这位小主管了，而是更多的思考如何减小汰换的影响，那么我们首先要考虑的主要有几个方面：</p>
<ul>
<li>部门其它TL的感官以及影响</li>
<li>小团队内其它骨干的影响</li>
<li>面对面沟通策略，他本人的应激反应以及可能的舆情</li>
<li>如何通过这个事情达到激发的目的</li>
</ul>
<p>所以针对上面的几个问题，具体在沟通之前需要完成以下这些事情，做好相关的预案。</p>
<hr />
<p>1、<strong>小团队其它成员的影响</strong></p>
<ul>
<li>借助绩效沟通的环境，识别可能得风险，提前安排相关骨干进行干预，同时做好绩效考核导向的要求，让同学理解绩效考核的目标；</li>
<li>目前看最可能有影响的是跟随一起进来的同学，需要做好随同离职的准备，目前其工作替代的可能性较高，风险较小；</li>
</ul>
<p>2、<strong>其它小团队主管及核心骨干的感官</strong></p>
<ul>
<li>需要跟其他小团队的主管进行提前沟通，做好他们自己团队内风险识别以及舆论识别，这个可能优先级排在第二；</li>
<li>部分核心同学也需要做好1对1的沟通，避免引起群体事件；</li>
<li>也通过这个事情，对相应的TL面前树立自我的威信以及提供警醒；</li>
</ul>
<p>3、<strong>其本人的沟通策略</strong></p>
<ul>
<li>首先让该同学自我描述一下上半年的整体输出，然后从绩效事实上面点评整体的问题；一定要做好事情的绩效梳理工作；</li>
<li>该同学肯定会不认同当前的绩效结果，需要收集相关的绩效事实，同时不强求必须认同该绩效结果，价值观方面的差异是很难对齐的；</li>
<li>如果该同学有过激的反应，在沟通过程中，及时让HR同学介入，沟通离职相关事宜；</li>
<li>部门方面做冷处理，不谈论该名同学的离职；但是在部门的大会上面，对于绩效考核的要求再次跟大家明确；</li>
<li>做好沟通时候的录音，只对事不对人，表达要求以及客观事实；</li>
</ul>
<p>4、<strong>如何通过这个事情达到激发的目的</strong></p>
<ul>
<li>本月的大会上面，需要重点就 <strong>绩效考核以及绩效导向</strong> 来给大家讲一下相关的事情，需要明确一下，什么是我们团队的价值观，对于低级别的同学以及对于高级别的同学的要求是什么，给大家把一些标准确定下来；</li>
<li>其次今年的重点工作的事情也需要让大家知道，给大家明确一下大家在不同工作领域里面应该如何做到极致，如何体现出自己的价值；</li>
</ul>
<hr />
<p>实际在职场中，汰换、离职是非常正常的，特别是在一些竞争激烈的行业里面，如果找不准自己的位置以及无法体现出自我的核心价值，是非常容易被汰换的；
无论做什么事情，都要去思考一下，我如果做了这件事，我如何能够体现出我跟别人做的不一样的地方，无论是效率、结果还是方式，如果跟别人做不出差别，或许下一个被替代的就是自己；
与君共勉！</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/28"/><category term="生活感悟"/><published>2024-08-12T05:58:01+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/27</id><title>目标140斤以内，是不是3个月内可实现的？</title><updated>2024-08-20T13:24:45.561851+00:00</updated><content type="html"><![CDATA[<p>谈减肥谈了很多次了，包括在朋友圈晒目标，跟朋友下决心，等等，经历过很多次，但是最终都失败了，似乎一直处于&quot;<em><strong>下决心，开始控制饮食+运动，然后中途放弃，最后又开始下决心</strong></em>&quot;的怪圈，始终无法彻底走出来；</p>
<p>所以，我们需要仔细分析一下，这个项目应该要怎么做？</p>
<!-- more -->
<h1>项目分解</h1>
<p>项目的目标很明确，减脂（不是减重），所以一开始说订立140斤的减肥目标其实是有误区的，应该说从将近30%的体脂率，减到一个正常的体脂率，那么正常偏低的体脂率，应该是多少呢？查了一下网图：
<img src="https://github.com/user-attachments/assets/a6e9911e-55f7-4539-8695-a035494a175b" alt="不同的体脂率" /></p>
<p>从上图的表现看，比较倾向的体脂率是大概：15%左右，所以取值15%作为减脂的目标；</p>
<p>那么按照15%的体脂，需要减脂多少g的脂肪呢？</p>
<p><img src="https://github.com/user-attachments/assets/d172e09c-6773-401b-9c2f-884d193181eb" alt="体脂公式" /></p>
<p>从这个公式中，我们将15%的体脂率带入，可以计算到：</p>
<p>目标脂肪含量为： <strong>9kg</strong>；
当前脂肪含量为： <strong>25.5kg</strong>
<strong>所以理论上需要减去脂肪约16.5kg，33斤，所以当前体重为： 170斤，目标体重为137斤；</strong></p>
<p>按照当前基础代谢计算，每天的热量缺口按照500大卡计算（假设全部脂肪供能），<strong>500卡路里相当于55克左右的脂肪</strong>，那么要达到16.5kg的总量，需要时间为： <strong>10</strong>个月;</p>
<p>所以正确的目标应该是： </p>
<p><strong>在10个月以内，体脂率从30%降低到15%，脂肪减去16.5kg， 每天至少保持500大卡的热量缺口！</strong></p>
<p>所以，尝试按照现在正常的目标进行减脂，最后，我们10个月后，看看效果；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/27"/><category term="生活感悟"/><published>2024-08-08T08:34:05+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/26</id><title>美股大跌，A股是跑路还是加仓？</title><updated>2024-08-20T13:24:45.671637+00:00</updated><content type="html"><![CDATA[<p><img src="https://github.com/user-attachments/assets/c0bf3d12-56c7-4a2b-98e3-bf27d3146dae" alt="美股大跌，A股跑路还是加仓？！" /></p>
<!-- more -->
<p><img src="https://github.com/user-attachments/assets/7f11ab86-1155-4844-8442-de8b21b74348" alt="美股大跌" /></p>
<p>这两天美股因为就业数据的问题，引起了机构对于投资美国的经济的担忧，导致美股大跌，那么对于A股是不是像上面说的，要赶紧跑路，因为从之前的情况来看，<strong>美股大涨，A股小涨，美股小跌，A股大跌</strong>；</p>
<p>但是从我的角度，当然目前只是感性的猜测，这几年美股加息，美元回流，推高了美股股市，在目前的全球政治局势下看，欧洲已经有点停滞不前了，中东战争进一步恶化的情况下，欧洲影响可能更大；目前可以容纳资本的，或许A股、港股是一个比较好的地方，虽然国内的经济数据也不好看，但是整体上，目前还能过得下去； 所以国内重仓高息分红的银行，我认为是比较保险的避险资产； </p>
<p>另外，想说的是，尽管这两天美股、日经都是暴跌，但是A股还相对稳定，略跌一点，说明A股当前已经走出了部分独立行情；此外，人名币快速升值，也是提供了美元回流的一大理由；
<img src="https://github.com/user-attachments/assets/cf47da39-7fb5-46c3-8c21-6ed71e6d3d0b" alt="人名币升值" /></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/26"/><category term="投资交易"/><published>2024-08-05T11:20:19+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/25</id><title>关于原型验证的思考</title><updated>2024-08-20T13:24:45.778306+00:00</updated><content type="html"><![CDATA[<h1>摘要</h1>
<p>在芯片项目的验证阶段中，主要分为硅前以及硅后两个大的阶段，在不同的阶段，各个团队的验证侧重点略有不同，但是同样的需要保证验证的质量，而验证的质量从验证的完备性去衡量；</p>
<p>而实际操作过程中，会根据芯片自研程度、模块规模、商用化目的、人力投入、职责划分等情况，验证策略会跟随着做出一些适时的调整，最终以在现有条件下达成芯片验证的目的；</p>
<p>在目前大部分芯片项目中，真正核心自研的东西其实并不太多，大部分情况下，更多的是三方集成+自研的模式，所以根据这种情况，项目应该以什么样的策略去应对，这个也是本文想要总结思考的；</p>
<!-- more -->
<h1>验证流程</h1>
<p>在一般的芯片公司，负责芯片验证的主要有几个相关的团队：</p>
<p>[<em>前端设计</em>] ---&gt; 前端验证 ---&gt; [<em>原型验证</em>] ---&gt; 底软解决方案</p>
<p><strong>前端设计</strong>会部分参与到前端验证的质量活动中，比如类似于代码review，覆盖率分析，波形检视等；</p>
<p><strong>前端验证</strong>在硅前阶段的时候，是芯片signoff的主要责任团队，从意义上来说，硅前阶段，只有前端验证可以从RTL代码层面上，进行白盒验证，保证验证的完备性；在硅后阶段，前端验证基本不参与验证；</p>
<p><strong>原型验证</strong>在有些公司不一定存在，原型验证主要的工作在硅前是在FPGA以及Emulation平台上面进行软硬件的原型验证，更加偏向于系统级别的场景验证、压力验证、性能验证以及各个模块配合的集成验证；硅后阶段，针对工程样片负责功能、压力、性能等验证，针对下游做功能的出口；因此这部分工作在有些公司或者小芯片项目中，被底软团队以及前端验证团队覆盖；</p>
<p><strong>底软解决方案</strong>在芯片开发验证过程中，主要是针对交付的SDK进行开发，在对SDK进行软件验证的同时，也能兼顾部分芯片功能的验证，但是更多偏向软件功能的交付，并且主要参与硅后阶段，硅前大部分情况下，只是进行软硬件方案的开发；</p>
<p>在海思、平头哥、Intel等大型芯片公司，都有类似的原型验证团队，可能在工作细节上面有些出入，但是大体上都差不多；</p>
<p><strong>芯片开发验证的大致流程</strong>以及阶段如下：</p>
<p><img src="https://github.com/user-attachments/assets/2b8d8217-f0b1-48aa-a2da-7d88ba7ea05c" alt="芯片开发验证流程" /></p>
<p><strong>TR1/TR2 阶段</strong>：这个阶段基本上原型验证不会参与，属于立项以及需求收集分析、架构设计阶段，</p>
<p><strong>TR3 阶段</strong>：这个阶段前端验证/原型验证开始大量投入：</p>
<ul>
<li>85%阶段：前端验证团队开始根据交付特性进行验证，原型团队开始做验证前的质量活动，验证方案开发、驱动代码开发，用例开发，模块冒烟等等；</li>
<li>100%阶段：前端验证基本大部分功能已经完成验证，原型团队也可以针对全量用例进行第一次整体测试，压力、性能等验证也相应启动；</li>
<li>Freezon阶段：RTL代码冻结，前端验证开始做覆盖率等质量活动，原型团队重点投入在性能Validation、压力验证等活动，部分质量活动也相应开启；</li>
<li>ECO阶段：前端验证质量活动基本完成，开始进行更细致的corner验证或者联合原型进行前后端验证增补、网表仿真启动等；原型启动TO前的用例全量回归，大部份质量活动完成</li>
<li>TO/TR4阶段：前端验证任务基本完成，原型验证开始准备CB点亮以及样片验证相关工作；</li>
</ul>
<p><strong>CB阶段（chip back）</strong>: 这个阶段芯片点亮以及验证的主力是原型验证团队以及底软解决方案团队，前者需要完成样片的点亮以及全量用例的测试，长时间大压力的测试也需要在这个阶段完成；芯片相关的性能数据的validation也需要完成输出以及优化；原型团队同时需要联合硬件团队完成电气特性测试以及SLT软件开发；底软团队开始针对样片的产品环境进行底软的调试，以及完成底软SDK的开发发布测试等流程活动，</p>
<p><strong>TR5阶段</strong>：标识芯片正式可以量产，相应测试以及质量、成本等达到设计预期，开始正式上市；</p>
<p>如上可知，原型团队主要在<strong>硅前做好前端验证的质量守门员</strong>，<strong>硅后芯片质量的交付团队</strong>；</p>
<h1>项目验证策略</h1>
<p>在实际项目的过程中，芯片开发大部分的情况下，芯片内部模块可能分成几类：</p>
<ul>
<li>A.完全自研的模块，并且首次使用</li>
<li>B.完全自研的模块，但是已经在多颗量产芯片上应用，修改量较小</li>
<li>C.第三方采购模块，但是首次应用项目</li>
<li>D.第三方采购模块，模块规模<strong>较小</strong>，并且已经多个量产芯片应用，修改量较小或无修改</li>
<li>E.第三方采购模块，设计规模<strong>较大</strong>，并且已经多个量产芯片应用，修改量较小或无修改</li>
</ul>
<p>按照验证的功能细致程度或者验证需求来分类，也可以根据上述模块，分成以下几类：</p>
<ul>
<li>全量验证，做好完备的测试点，甚至在原型阶段尽量做到白盒化验证；（比如上述A类型模块）</li>
<li>增量验证，做好集成验证，主要包含性能、压力、增量特性以及自动化测试套；（比如上述B/C/E类型模块）</li>
<li>以用代验，通过验证系统，其它模块配合验证，以用代验的方式，完成验证；(比如上述D类型模块)</li>
</ul>
<p>在原型验证的不同阶段，职责也会有相应的区分，因此在侧重点上也有一定的倾向，这里会对原型验证的自动化程度有比较高的要求，只有在高度自动化的情况下，可以实现以最小的人力，最快的速度完成对于相应验证工作的快速闭环以及人力的节省；</p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/25"/><category term="总结思考"/><published>2024-08-05T07:47:01+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/24</id><title>python In 机器学习(一)</title><updated>2024-08-20T13:24:45.907445+00:00</updated><content type="html"><![CDATA[<h1>LinearRegression</h1>
<p>这里简单记录一下最近学习的算法代码</p>
<!-- more -->
<h2>多元线性回归算法</h2>
<p>这里主要通过sklearn获取数据进行实验</p>
<pre><code class="language-python">from sklearn import *
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import torch

if __name__ == &#x27;__main__&#x27;:
    # 加载糖尿病数据集
    data = datasets.load_diabetes()
    data_X = data.data
    data_Y = data.target
    # 拆分训练集以及预测数据
    X_train, X_test, Y_train, Y_test = train_test_split(data_X, data_Y, test_size=0.2)

    # 创建一个多元线性回归算法对象
    lr = LinearRegression()

    # 使用训练集训练模型
    lr.fit(X_train, Y_train)

    # 使用测试集进行预测
    Y_pred = lr.predict(X_test)
    Y_pred_train = lr.predict(X_train)
    # 打印模型的均方差
    print(f&quot;pred loss : {mean_squared_error(Y_test, Y_pred)}&quot;)

    print(f&quot;Y_pred_train loss : {mean_squared_error(Y_train, Y_pred_train)}&quot;)
    pass

</code></pre>
<h2>分类</h2>
<p>这里是分类的应用：</p>
<ul>
<li>logistics回归 ： OVR，one vs other，将多分类当成多个二分类</li>
<li>softmax：一次得到多个分类的概率</li>
</ul>
<pre><code class="language-python">from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

if __name__ == &#x27;__main__&#x27;:
    # 加载数据
    iris = datasets.load_iris()

    X = iris.data
    Y = iris.target

    print(f&quot;Y = {Y}&quot;)

    # 切分数据
    X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2)

    # 创建模型, 根据数据决定是用二分类还是多分类
    # 使用logistics回归还是softmax回归 ，取决于multiclass参数
    # ovr ： 1对其它
    # multinomial ： softmax
    #  &quot;multi_class&quot;: [
    #             StrOptions({&quot;auto&quot;, &quot;ovr&quot;, &quot;multinomial&quot;}),
    #             Hidden(StrOptions({&quot;deprecated&quot;})),
    #         ],
    lr = LogisticRegression(max_iter=1000000)

    # 使用训练集训练模型
    lr.fit(X_train, y_train)

    # 对测试集进行预测
    y_pred = lr.predict(X_test)

    # 打印模型的准确率
    print(f&quot;accuracy = {accuracy_score(y_test, y_pred)}&quot;)

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/24"/><category term="python 机器学习"/><published>2024-08-03T08:25:19+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/16</id><title>聊一聊职业机会</title><updated>2024-08-20T13:24:46.011303+00:00</updated><content type="html"><![CDATA[<p>挺有意思的一件事，最近公司在做组织结构调整，有基层领导岗位的竞聘机会，于是给到自己团队内的核心骨干提示，希望相关骨干能够有勇气，有能力去竞聘一下，本以为会有比较多的同学尝试一下，但是实际的结果却出乎我的意料，最终竞聘的时候，没有一个同学敢于尝试；这里就引申了一个话题，作为研发人员，在职场的机会是什么？</p>
<!-- more -->
<h1>回顾</h1>
<p>我在研发行业也算从业了10多年了，从一个基层研发到10来人的小团队leader到现在leader了几十上百人，其实看到过很多人包括自己在工作中经常会有的思考：</p>
<ul>
<li>我现在做的这个事情的意义是什么</li>
<li>我在这里做几年后，我未来应该要怎么走</li>
<li>是不是要换个方向</li>
<li>要不要跳槽，换个公司</li>
</ul>
<p>这里我们先把这些问题放置一边，简单回顾一下自己这些年职场发展过程；</p>
<hr />
<p>在自己的职业发展过程中，一方面确实吃到了时代的红利，给了自己在工作、待遇上非常大的帮助；另外一方面，个人在其中也是花了很大的精力；
总结这十多年的过程来看，我认为主要有几个点起到了关键性的作用：</p>
<ul>
<li>韧性</li>
<li>学习能力</li>
<li>做事的方式方法</li>
</ul>
<h2>韧性</h2>
<p>为什么把<strong>韧性</strong>排在了第一位？
这不得不回想起整个职业生涯里面的几个关键节点：
<strong>第一个节点</strong>是初入职场时候身份的转变，我们从象牙塔里面出来，之前最大的压力，无非是作业、考试，影响的仅仅是自己一个人，但是项目职场中，个人的事务往往牵扯上下游相关的同事，一个人进度的影响可能导致的是整个周边的delay，这里带来的情绪上，压力上的强度是相比之前不可同日而语的；</p>
<p>回想同一批进入华为的同学，大概一个大班级有150人左右，一年后，剩余的不过80人，基本已经淘汰一半 ，而这一半很多同学是无法适应在激烈对抗的公司里面的压力而离开的；</p>
<p><strong>第二个节点</strong>，是工作三年后，这个时候，容易产生职场的疲惫，特别是在华为这样的公司里面，竞争激烈，工作强度大，很容易造成放弃；</p>
<p>还记得15年的时候，当时在实验室里面连续工作了3~4个月，巨大的工作强度以及工作压力，差一点就提了离职，5.1号劳动节当天回了老家买房，本来打算回来就提离职的，不过因为最后想着再咬咬牙坚持一下，最终还是扛过了这段黑暗的时光，也熬出了一个很好的上升机会；</p>
<p><strong>第三个节点</strong>，是自己升任团队基层管理者的时候，带了10个人负责一个方向的事务，工作开始变得杂乱，不像以前那么单纯，这个时候，由于有了一定的能力，周边的干扰开始多了起来，各种相关的职场机会也找来了，但是是不是找来的一定是个好机会，不一定见得，但是知道得是，那个阶段走出去得同学，目前看，还没有在职场混的更好得同学；</p>
<p>以上想说明得是什么？很多时候，我们认为一些事情很难扛过去，但是咬咬牙，等这件事情真的过去了之后，再看看，其实好像也没有什么，反而在这个过程中，我们得能力、影响力都得到了提升；</p>
<p>所以，人一定要有<strong>韧性，耐操，不玻璃心</strong>，这个是我认为在职场中，最为核心的内在能力之一</p>
<h2>学习能力</h2>
<p>个人认为第二重要的就是学习能力！</p>
<p>在笔者经历的这些大厂的工作生涯里面，对于一个新的领域，是否能够很快的上手，很快的掌握核心能力，是决定一个人能否拿出结果的重要能力；</p>
<p>在学校阶段，笔者是学习J2EE的，即java/struct/hibernate/spring这一套，但是入职后，就被分配到了芯片行业，当时我连arm芯片是什么都不知道，刚入职领导让用C写一个简单的memory copy也整不明白，更不用说，对于底层软件的执行逻辑、操作系统的理解了，毕竟大学都是60分万岁通过的；</p>
<p>但是入职半年左右，通过没日没夜的学习，笔者很快在同年入职的新员工里面脱颖而出，特别的是大部分还是研究生，拿到了当年的最佳新员工；</p>
<p>这里面，当然也有一些技巧，简单来说，笔者学习总是伴随着问题学习，以解决问题为目的的学习，同时伴随着模仿以及厚脸皮的请教，能够很快的上手项目工作并且顺利的交付；</p>
<p>当然，这样的学习方式也是有一定的代价，掌握的深度有点不够的，但是能够快速的掌握大量的知识，在广度上，帮助非常大；至于深度，则需要跟随自己手上的工作花更多的精力去掌握~</p>
<h2>做事的方式方法</h2>
<p><strong>酒香还怕巷子深</strong></p>
<p><strong>低调做人，高调做事！</strong></p>
<p>笔者做事的方式一向比较高调，不管是及时的跟自己的领导同步进展，还是积极主动的去寻求问题的解决办法，总之，一切以把事情完成为目的的去做事，这个过程可能很多人会觉得很高调，类似于献殷勤！</p>
<p>但是需要明白的是，这个跟献殷勤是有很大的区别的，这里的区别在于献殷勤更多的是打感情牌，而主动的沟通交流，主动的汇报进展，更多的是像领导展现自己的能力，中国人向来含蓄，但是笔者认为在职场中，能多外向就多外向，外向型性格，在职场中，总是会吃得香~</p>
<hr />
<p>说了这么多，其实笔者最后想总结的一点是：</p>
<p>机会，是留给有准备的人，是留给主动争取的人，是留给有韧性、学习能力、懂做事方法的人，当机会出现的时候，就要积极的去尝试，争取，哪怕是去露个脸，也总比白白放过要强~</p>
<p>这里也是提醒自己，<strong>生活中，有些机会稍纵即逝，把握与放弃，就在一念之间！</strong></p>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/16"/><category term="生活感悟"/><published>2024-06-04T05:54:14+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/15</id><title>Qemu Virt平台集成ARM PL080 DMA</title><updated>2024-08-20T13:24:46.155133+00:00</updated><content type="html"><![CDATA[<h1>背景</h1>
<p>最近有比较多的新员工入职，新员工入职如何更快的适应工作，需要通过一些虚拟项目进行工作培训；但是如果利用现有的芯片平台进行验证，有几个缺陷：</p>
<ul>
<li>当前芯片略显复杂，新员工接手理解难度较高</li>
<li>平台已经solid，并且有参考的代码以及测试用例，对于新员工而言，没有起到端到端cover一个模块的作用</li>
<li>难以预埋bug，无法通过挖掘设计bug，衡量验证效果</li>
</ul>
<p>因此根据实际工作需求，设计了一个可以给到新员工练兵的验证项目，利用qemu平台，集成一个简单的DMA模块，并且在模块中预埋一些bug，让新员工提前感知在后续验证过程中，应该要重点关注的一些验证重点，验证难点，同时也可以观察在整个新员工项目过程中，新员工的表现，识别高潜人才；</p>
<!-- more -->
<h1>验证平台开发</h1>
<h2>集成开发环境</h2>
<p>Qemu针对arm类的处理器，提供了一个单纯的开发环境，Virt平台，如下是virt平台的一些简述：</p>
<blockquote>
<p><a href="https://www.qemu.org/docs/master/system/riscv/virt.html#virt-generic-virtual-platform-virt">‘virt’ Generic Virtual Platform</a>
The virt board is a platform which does not correspond to any real hardware; it is designed for use in virtual machines. It is the recommended board type if you simply want to run a guest such as Linux and do not care about reproducing the idiosyncrasies and limitations of a particular bit of real-world hardware.
<a href="https://www.qemu.org/docs/master/system/riscv/virt.html#supported-devices">Supported devices</a>
The virt machine supports the following devices:</p>
<ul>
<li>Up to 512 generic RV32GC/RV64GC cores, with optional extensions</li>
<li>Core Local Interruptor (CLINT)</li>
<li>Platform-Level Interrupt Controller (PLIC)
*CFI parallel NOR flash memory</li>
<li>1 NS16550 compatible UART</li>
<li>1 Google Goldfish RTC</li>
<li>1 SiFive Test device</li>
<li>8 virtio-mmio transport devices</li>
<li>1 generic PCIe host bridge</li>
<li>The fw_cfg device that allows a guest to obtain data from QEMU
The hypervisor extension has been enabled for the default CPU, so virtual machines with hypervisor extension can simply be used without explicitly declaring.</li>
</ul>
</blockquote>
<p>所以在Virt平台中，简单集成一下virtio-mmio设备即可；</p>
<p>于此同时，对于验证新手项目而言，DMA设备是一个能够比较小巧又比较全面的设备，因此可以选择一个相对简单的DMA集成到环境中即可；</p>
<h2>DMA选型</h2>
<p>在原生qemu 代码中，提供了如下几款DMA设备：</p>
<ul>
<li>bcm2835_dma</li>
<li>omap_dma</li>
<li>arm pl080 dma</li>
<li>arm pl330 dma</li>
<li>xlnx的3款dma</li>
<li>...
<img src="https://github.com/Jared-ZDC/markel/assets/17999499/8631ad56-50c5-4a4d-b657-699aaee31024" alt="qemu dma" /></li>
</ul>
<p>从选择的几个dma spec内容看起来，arm的pl080 dma相对简单，并且有完善的spec资料以及开源支持的驱动代码，因此在选型上个人更偏向arm PL080 DMA设备；</p>
<h2>集成DMA</h2>
<p>qemu virt集成的方式比较简单，首先看一下pl080的设备描述：</p>
<pre><code class="language-c">static Property pl080_properties[] = {
    DEFINE_PROP_LINK(&quot;downstream&quot;, PL080State, downstream,
                     TYPE_MEMORY_REGION, MemoryRegion *),
    DEFINE_PROP_END_OF_LIST(),
};
</code></pre>
<p>PL080的属性只有一个downstream， 类型是memory region类型，表示dma 链接系统memory的区域， 因此在qemu virt平台中集成只要对downstream进行处理即可：</p>
<pre><code class="language-c">//virt.c
static const MemMapEntry base_memmap[] = {
    /* Space up to 0x8000000 is reserved for a boot ROM */
    [VIRT_FLASH] =              {          0, 0x08000000 },
...
    [VIRT_DMA] =                { 0x09011000, 0x00001000 },
...
    [VIRT_MEM] =                { GiB, LEGACY_RAMLIMIT_BYTES },
};

static const int a15irqmap[] = {
    [VIRT_UART] = 1,
    [VIRT_RTC] = 2,
...
    [VIRT_PLATFORM_BUS] = 112, /* ...to 112 + PLATFORM_BUS_NUM_IRQS -1 */
    [VIRT_DMA] = 212,
};
static void create_dma(const VirtMachineState *vms)
{
    int i;
    char *nodename;
    hwaddr base = vms-&gt;memmap[VIRT_PDMA].base;
    hwaddr size = vms-&gt;memmap[VIRT_PDMA].size;
    int irq = vms-&gt;irqmap[VIRT_PDMA];
    const char compat[] = &quot;arm,pl080\0arm,primecell&quot;;
    const char irq_names[] = &quot;intr\0interr\0inttc&quot;;
    DeviceState *dev;
    MachineState *ms = MACHINE(vms);
    SysBusDevice *busdev;

    dev = qdev_new(&quot;pl080&quot;);

    object_property_set_link(OBJECT(dev), &quot;downstream&quot;, OBJECT(get_system_memory()), &amp;error_fatal);

    busdev = SYS_BUS_DEVICE(dev);
    sysbus_realize_and_unref(busdev, &amp;error_fatal);
    sysbus_mmio_map(busdev, 0, base);

    for (i = 0; i &lt; 3; ++i) {
        sysbus_connect_irq(busdev, i, qdev_get_gpio_in(vms-&gt;gic, irq + i));
    }

    nodename = g_strdup_printf(&quot;/pl080@%&quot; PRIx64, base);
    qemu_fdt_add_subnode(ms-&gt;fdt, nodename);
    qemu_fdt_setprop(ms-&gt;fdt, nodename, &quot;compatible&quot;, compat, sizeof(compat));
    qemu_fdt_setprop_sized_cells(ms-&gt;fdt, nodename, &quot;reg&quot;,
                                 2, base, 2, size);
    qemu_fdt_setprop_cells(ms-&gt;fdt, nodename, &quot;interrupts&quot;,
                    GIC_FDT_IRQ_TYPE_SPI, irq, GIC_FDT_IRQ_FLAGS_LEVEL_HI,
                    GIC_FDT_IRQ_TYPE_SPI, irq + 1, GIC_FDT_IRQ_FLAGS_LEVEL_HI,
                    GIC_FDT_IRQ_TYPE_SPI, irq + 2, GIC_FDT_IRQ_FLAGS_LEVEL_HI);

    qemu_fdt_setprop(ms-&gt;fdt, nodename, &quot;interrupt-names&quot;, irq_names,
                     sizeof(irq_names));

    qemu_fdt_setprop_cell(ms-&gt;fdt, nodename, &quot;clocks&quot;, vms-&gt;clock_phandle);
    qemu_fdt_setprop_string(ms-&gt;fdt, nodename, &quot;clock-names&quot;, &quot;apb_pclk&quot;);

    g_free(nodename);
}

</code></pre>
<p>为了验证集成dma的寄存器访问正确性， 单独将0x64寄存器设置为魔术字寄存器，可读，可写</p>
<pre><code class="language-patch">//dma集成读写测试用
diff --git a/qemu/qemu-8.1.4/hw/dma/pl080.c b/qemu/qemu-8.1.4/hw/dma/pl080.c
index a03dcf428..9ff191a02 100644
--- a/qemu/qemu-8.1.4/hw/dma/pl080.c
+++ b/qemu/qemu-8.1.4/hw/dma/pl080.c
@@ -221,6 +221,8 @@ static uint64_t pl080_read(void *opaque, hwaddr offset,
     uint32_t i;
     uint32_t mask;

+    qemu_log_mask(LOG_GUEST_ERROR,&quot;pl080_read %x, %d,  size %x\n&quot;, offset, offset &gt;&gt; 2, size);
+
     if (offset &gt;= 0xfe0 &amp;&amp; offset &lt; 0x1000) {
         if (s-&gt;nchannels == 8) {
             return pl080_id[(offset - 0xfe0) &gt;&gt; 2];
@@ -275,6 +277,8 @@ static uint64_t pl080_read(void *opaque, hwaddr offset,
         return s-&gt;conf;
     case 13: /* Sync */
         return s-&gt;sync;
+    case 16: /*magic word*/
+       return s-&gt;magic_words;
     default:
     bad_offset:
         qemu_log_mask(LOG_GUEST_ERROR,
@@ -289,6 +293,7 @@ static void pl080_write(void *opaque, hwaddr offset,
     PL080State *s = (PL080State *)opaque;
     int i;

+    qemu_log_mask(LOG_GUEST_ERROR,&quot;pl080_write %x, size %x, value %x\n&quot;, offset, size, value);
     if (offset &gt;= 0x100 &amp;&amp; offset &lt; 0x200) {
         i = (offset &amp; 0xe0) &gt;&gt; 5;
         if (i &gt;= s-&gt;nchannels)
@@ -338,6 +343,8 @@ static void pl080_write(void *opaque, hwaddr offset,
     case 13: /* Sync */
         s-&gt;sync = value;
         break;
+    case 16: /*magic word*/
+       s-&gt;magic_words = value;
     default:
     bad_offset:
         qemu_log_mask(LOG_GUEST_ERROR,
@@ -366,7 +373,7 @@ static void pl080_reset(DeviceState *dev)
     s-&gt;req_single = 0;
     s-&gt;req_burst = 0;
     s-&gt;running = 0;
-
+    s-&gt;magic_words = 0x55aa55aa;
     for (i = 0; i &lt; s-&gt;nchannels; i++) {
         s-&gt;chan[i].src = 0;
         s-&gt;chan[i].dest = 0;
</code></pre>
<h2>编译</h2>
<p>将qemu编译完成后，使用如下命令启动系统：</p>
<pre><code class="language-bash">build/qemu-system-aarch64 \
    -nographic \
    -M virt,virtualization=true,gic-version=3 \
    -cpu cortex-a76 \
    -smp 4 \
    -m 8G \
    -kernel ../../linux/linux-6.6/arch/arm64/boot/Image \
    -append &quot;rootfstype=ramfs rdinit=/linuxrc console=ttyAMA0&quot; \
    -initrd ../../busybox/busybox-1.36.1/initrd.cpio.gz
</code></pre>
<h2>测试</h2>
<h3>dump dma寄存器</h3>
<p>通过dump dma的寄存器，简单看一下dma寄存器是否按照预期集成完成</p>
<pre><code class="language-bash">[root:DMA: ~]# devmem 0x9012040
0x55AA55AA
[root:DMA: ~]# devmem 0x9012040 32 0xaa55aa55
[root:DMA: ~]# devmem 0x9012040
0xAA55AA55
</code></pre>
<p>寄存器读写功能正常</p>
<h3>dma搬运测试</h3>
<h4>dma测试驱动</h4>
<p>简单写一个dma测试代码，搬运两个地址的数据，并进行搬运后数据检查，看看中断是否正常上报</p>
<pre><code class="language-c">static ssize_t memcpy_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {
    // 实现 memcpy 文件的写操作
    // 检查输入参数
    if (count &gt; BUFFER_SIZE) {
        return -EINVAL;
    }

    // 从用户空间拷贝数据到 buffer_in
    if (copy_from_user(buffer_in, buf, count)) {
        return -EFAULT;
    }

    // 设置 DMA 传输参数
    struct dma_async_tx_descriptor *desc;
    dma_addr_t src_addr = virt_to_phys(buffer_in);
    dma_addr_t dst_addr = virt_to_phys(buffer_out);

    memset(buffer_in,0x5a,0x40);
    memset(buffer_out,0x0,0x40);
    pr_info(&quot;dump buffer_in\n&quot;);
    dump(buffer_in, 0x40);


    desc = dmaengine_prep_dma_memcpy(dma_chan, dst_addr, src_addr, 0x40, DMA_MEM_TO_MEM);
    if (!desc) {
        pr_err(&quot;Failed to prepare DMA transfer\n&quot;);
        return -EBUSY;
    }

    desc-&gt;flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
    // 设置 DMA 完成中断处理函数
    desc-&gt;callback = dma_complete_callback;
    desc-&gt;callback_param = NULL;

    pr_err(&quot;prepare to sumbit\n&quot;);

    // 启动 DMA 传输
    dmaengine_submit(desc);
    pr_err(&quot;prepare to async\n&quot;);
    dma_async_issue_pending(dma_chan);

    msleep(2000);

    pr_info(&quot;dump buffer_out\n&quot;);
    dump(buffer_out, 0x40);

    // 等待 DMA 传输完成
    /*
    while (!dma_complete) {
        cpu_relax();
    }
*/
 //   dma_complete = false;
    return count;
}

static int dmatest_device_init(void)
{
    // 1. 创建设备类
    dmatest_device_class = class_create(&quot;dmatest_device_class&quot;);
    if (IS_ERR(dmatest_device_class)) {
        printk(KERN_ERR &quot;Failed to create device class\n&quot;);
        return PTR_ERR(dmatest_device_class);
    }

    // 2. 创建设备
    dmatest_device = device_create(dmatest_device_class, NULL, MKDEV(230, 0), NULL, &quot;dmatest&quot;);
    if (IS_ERR(dmatest_device)) {
        printk(KERN_ERR &quot;Failed to create device\n&quot;);
        class_destroy(dmatest_device_class);
        return PTR_ERR(dmatest_device);
    }

    printk(KERN_INFO &quot;dmatest_device created successfully\n&quot;);
    return 0;
}


static int dmatest_init(void) {



    if(dmatest_device_init())
        return -1;

    dmatest_dir = proc_mkdir(&quot;dmatest&quot;, NULL);
    if (!dmatest_dir) {
        pr_err(&quot;Failed to create dmatest directory in procfs\n&quot;);
        return -ENOMEM;
    }

    memcpy_file = proc_create(&quot;memcpy&quot;, 0644, dmatest_dir, &amp;memcpy_fops);
    if (!memcpy_file) {
        pr_err(&quot;Failed to create memcpy file in procfs\n&quot;);
        remove_proc_entry(&quot;dmatest&quot;, NULL);
        return -ENOMEM;
    }

    status_file = proc_create(&quot;status&quot;, 0444, dmatest_dir, &amp;status_fops);
    if (!status_file) {
        pr_err(&quot;Failed to create status file in procfs\n&quot;);
        remove_proc_entry(&quot;memcpy&quot;, dmatest_dir);
        remove_proc_entry(&quot;dmatest&quot;, NULL);
        return -ENOMEM;
    }

    pr_info(&quot;dmatest directory and files created in procfs\n&quot;);
    return 0;
}

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/15"/><category term="程序人生"/><published>2024-06-04T05:34:28+00:00</published></entry><entry><id>https://github.com/Jared-ZDC/markel/issues/14</id><title>交叉编译Openblas库</title><updated>2024-08-20T13:24:46.297294+00:00</updated><content type="html"><![CDATA[<h1>下载源码</h1>
<pre><code class="language-bash">git clone https://github.com/OpenMathLib/OpenBLAS.git
</code></pre>
<h1>编译</h1>
<pre><code class="language-bash">gmake TARGET=ARMV8 BINARY=64 HOSTCC=gcc CC=aarch64-linux-gnu-gcc FC=aarch64-linux-gnu-gfortran

#可以查看Targetlist.txt看支持哪些目标平台
</code></pre>
<!-- more -->
<h2>注意</h2>
<p><img src="https://github.com/Jared-ZDC/markel/assets/17999499/bca51fc3-2640-463d-8cf8-2d5387540244" alt="image" />
出现这种错误，是因为可能存在windows跟unix的脚本转换错误，这里使用dos2unix将系统目录整体处理一边</p>
<pre><code class="language-bash">dos2unix ./*
dos2unix exports/gensymbol
</code></pre>
<h1>编译完成</h1>
<pre><code class="language-bash"> OpenBLAS build complete. (BLAS CBLAS LAPACK LAPACKE)

  OS               ... Linux
  Architecture     ... arm64
  BINARY           ... 64bit
  C compiler       ... GCC  (cmd &amp; version : aarch64-linux-gnu-gcc (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0)
  Fortran compiler ... GFORTRAN  (cmd &amp; version : GNU Fortran (Ubuntu 10.5.0-1ubuntu1~22.04) 10.5.0)
  Library Name     ... libopenblas_armv8p-r0.3.27.dev.a (Multi-threading; Max num-threads is 20)

To install the library, you can run &quot;make PREFIX=/path/to/your/installation install&quot;.
</code></pre>
<h1>编译benchmark</h1>
<pre><code class="language-bash">cd benchmark
gmake TARGET=ARMV8 BINARY=64 HOSTCC=gcc CC=aarch64-linux-gnu-gcc FC=aarch64-linux-gnu-gfortran
</code></pre>
<h1>测试</h1>
<pre><code class="language-bash">
#设置循环次数
export OPENBLAS_LOOPS=10000000
export OPENBLAS_PARAM_M=200
export OPENBLAS_PARAM_N=200
export OPENBLAS_PARAM_K=200

#设置线程数量，对于某些测试，不一定生效
export OPENBLAS_NUM_THREADS=4

#测试
./sgemm.goto 

</code></pre>
]]></content><link href="https://github.com/Jared-ZDC/markel/issues/14"/><category term="程序人生"/><published>2024-06-03T08:06:28+00:00</published></entry></feed>